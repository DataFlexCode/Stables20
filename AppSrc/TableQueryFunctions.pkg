//> This package provides an interface for finding records without the use of DataDictionaries.
//>
//> The idea is that you declare a variable of type tTableQuery and tell it what table and
//> filters you want and what output order you want. TQ then calculates the index to use for the
//> scan. If it can not find an index in accordance with the desired output it will collect
//> all the sorting information in memory and refind the records in the desired order.
//>
//> If the code happens to be running against an MSSQL backend it will skip all the figuring
//> out and apply embedded SQL to the problem. This gives a potential performance increase.
//>
//> oTQ is a global object (of class cTableQueryFunctions) that encapsulates a group of
//> functions. Using it to scan all orders in the order table goes like this:
//>
//> <code>
//>     Use TableQueryFunctions.pkg // Define oTQ object
//>
//>     Procedure RunQuery
//>         tTableQuery stQ // I use the prefix 'st' to signify a struct type
//>
//>         Get NewQuery of oTQ Order.File_Number to stQ
//>
//>         While (FindRecord(oTQ,&stQ))
//>             Showln Order.Order_Number
//>         Loop
//>     End_Procedure
//> </code>
//>
//> Note that the stQ parameter is passed "by reference" to the FindRecord
//> function. That variable maintains the complete state of the scan and it is
//> modified for each iteration. The table query object itself is stateless.
//>
//> For every loop of the FindRecord function the record buffer of the order
//> table will be active with the record found. If you are planning on modifying or
//> deleting these rows you should force a "prefetch" of the rows by inserting
//>
//> <code>
//>     Send ForcePrefetch of oTQ (&stQ)
//> </code>
//>
//> right after the "Get NewQuery..." line. Transparantly to the FindRecord loop this
//> will find all the rows in advance and store their rowid's in an array. Only
//> then will it start looping through the array finding each record (again) by its rowid.
//>
//>
//> Not having to constantly write 'of oTQ' the code becomes easier to
//> read and therefore this form will be used from here on. But in real life, always
//> use the oTQ object.
//>
//>
//> Now let us say that we wanted (1) all invoices for a particular customer that was (2)
//> payed after a given date. Furthermore this Invoice table has a column called Country
//> and (3) we only want invoices for a subset of countries. And the records should be
//> ordered by the amount on the order, highest amount first (4).
//>
//> <code>
//>  Object oMyQuery is a cTableQueryFunctions
//>      Procedure RunQuery
//>          String[] aCountries
//>          tTableQuery stQ
//>
//>          Get ListOfCountries to aCountries // Arbitrary list. It's an array of strings. That's what's important.
//>
//>          Get NewQuery Invoice.File_Number to stQ
//>          Send AddFilterRelate (&stQ) Customer.File_Number // 1
//>          Send AddFilter (&stQ) File_Field Invoice.Payed_Date tqGT dSomeDate // 2
//>          Send AddFilterInlist (&stQ) File_Field Invoice.Country aCountries // 3 (must be a string array no matter the column data type)
//>
//>          // And we also want it to be ordered backwards by the order total:
//>          Send AddOrderBy (&stQ) File_Field Invoice.Total True False // 4 (bDescending=True bUppercase=False)
//>          // (add more ordering segments)
//>
//>          While (FindRecord(Self,&stQ))
//>              Showln Invoice.Invoice_Number " " Invoice.Total
//>          Loop
//>      End_Procedure
//>  End_Object
//> </code>
//>
//> If you look at filter (2) in the example above you can see that the ">"-comperator is represented by
//> a tqGT symbol. Other comperators that may be used are:
//>
//>              tqLT, tqLE, tqEQ, tqGE, tqGT, tqNE
//>
//> end then there are these special ones intended for string evaluation:
//>
//>              tqMATCH, tqUCMATCH
//>
//>
//>
//> You can run nested queries like this:
//>
//> <code>
//>     Object oMyQuery is a cTableQueryFunctions
//>         Procedure RunQuery
//>             tTableQuery stOrderQ stOrderLineQ
//>
//>             Get NewQuery Order.File_Number to stOrderQ
//>
//>             While (FindRecord(Self,&stOrderQ)) // <-- Go through all orders
//>                 Get NewQuery OrderLine.File_Number to stOrderLineQ
//>                 Send AddFilterRelate (&stOrderLineQ) Order.File_Number
//>
//>                 While (FindRecord(Self,&stOrderLineQ)) // <-- Go through all lines on active order
//>                     // Something
//>                 Loop
//>             Loop
//>         End_Procedure
//>     End_Object
//> </code>
//>
//> If you have a 2 level scan like above, you can save execution time by creating
//> the sub-query only once and then call ReUse to reinitialise it.
//>
//> With the ReUse method you can skip the repeated compilation (of the inner query):
//>
//> <code>
//>     Object oMyQuery is a cTableQueryFunctions
//>         Procedure RunQuery
//>             Open Order
//>             Open OrderLin
//>             tTableQuery stOrderQ stOrderlineQ
//>             Get NewQuery Order.file_number to stOrderQ
//>             Get NewQuery OrderLin.file_number to stOrderlineQ
//>             Send AddFilterRelate (&stOrderlineQ) Order.file_number
//>
//>             While (FindRecord(Self,&stOrderQ))
//>                 Send ReUse (&stOrderlineQ) // <-- Only "compile" first time
//>                 While (FindRecord(Self,&stOrderlineQ))
//>                 Loop
//>             Loop
//>         End_Procedure
//>     End_Object
//> </code>
//>
//> You may use the .iLimit member of the tTableQuery value to limit
//> the number of rows returned:
//>
//> <code>
//>     Send SetLimit (&stQ) 50
//> </code>
//>
//> And finally, to quickly find out if a query will return any rows at all
//> you can call function HasData:
//>
//> <code>
//>     Get HasData stQ to bContinue // Note that stQ for once is _not_ byref'ed.
//> </code>
//>
//> Calling HasData could be a lot faster than setting iLimit to 1 since the latter
//> may still force the tablequery to generate the whole result-set and
//> sort it to find out which record is actually the first. Calling
//> HasData does not do that.
//>
//> If the table that you are querying is an SQL table that has been "opened as", TableQuery
//> has no way of knowing what table name to use in the select statement. If you prepare the
//> query with this line:
//>
//> <code>
//>     Send ForceSQLTableName (&stQ) "Customer"
//> </code>
//>
//> that name will be used in the ESQL select statement and you'll be fine.
//>

//> pkg.doc.end

// DAW packages:
Use VdfBase.pkg
Use cli.pkg
Use sql.pkg

// Stables packages
Use DateFunctions.pkg   // oDateFunctions object
Use StringFunctions.pkg // oStringFunctions object
Use IndexFunctions.pkg
Use StackFunctions.pkg  // oStackFunctions object
Use FileFunctions.pkg   // oFileFunctions object
#IFNDEF Is$WebApp // If Windows application
Use TemporaryTables.pkg
#ENDIF
Use WindowsInfo.pkg
Use SQLStatementHandles.pkg
Use TableDriverFunctions.pkg
Use StructFunctions.pkg
Use RecordBufferFunctions.pkg
Use cExpressionParser.pkg

Enum_List // Column value types
    Define tqSTRING
    Define tqNUMBER
    Define tqTEXT
    Define tqDATE
    Define tqDATETIME
End_Enum_List

Enum_List // Filter comparison modes
    Define tqLT for 0
    Define tqLE for 1
    Define tqEQ for 2
    Define tqGE for 3
    Define tqGT for 4
    Define tqNE for 5
    Define tqMATCH for 6     // When evaluated on the embedded database tqMATCH and tqUCMATCH may be
    Define tqUCMATCH for 7   // expensive. On SQL they are converted to 'like' predicates and they fly.

    Define _tqComparisonMax for 8  // Stop-marker
End_Enum_List

Struct tTQResultRow
    RowID    riRowId
    String[] aSortColumnValues
    String[] aColumnValues
End_Struct

Struct tTQResultSet
    Integer iTable
    tTQResultRow[] aRecords
    Integer _iCurrentRowPointer
End_Struct

Struct _tTQValueSource
    // An actual value is derived like this:
    //  If iTable<>0 then: get_field_value iTable iColumn
    //  If SizeOfArray(aSymbols)>0: It's an expression
    //  Else If (hFunction<>0) then: get hFunction of hObject iColumn // Column is passed to hFunction as argument
    //  Else If aOrList has elements the value of the _iOrListPointer'th element in aOrList is assumed
    //  Else: sConstant
    Integer iTable
    Integer iColumn

    Integer hObject
    Integer hFunction
    
    tXPToken[] aSymbols

    Integer iType
    Integer iLen
    Integer iDecimals

    // If the value is expression (sizeofarray(aSymbols)>0) 
    // then we save the proginal expression in sConstant, which
    // is variable overloadning, since sConstant is originally
    // intended for constant values only.
    String  sConstant

    String _sValue

    String[] aOrList
    Integer _iOrListPointer

    String  sSQLResultSetColumnName
//    Integer iSQLResultSetColumnNumber // This is implicitly given by the position of the _tTQValueSource member in the aSelectedColumns array of a tTableQuery type variable.
End_Struct

Struct tTQFilterSegment
    _tTQValueSource stLeftValue
    Integer iComp // tqEQ, tqLT, tgLE, tqMATCH etc...
    tWildCardEvalSequence stMatchEvalSequence // If selection by wild card string matching this member is needed
    _tTQValueSource stRightValue
    Boolean bUppercaseFilter // Uppercase both sides before compare (!!!! ONLY FOR INTERNAL USE !!!!)
End_Struct

Struct _tTQTableRelationSegment
    Integer iSourceTable
    Integer iSourceColumn
    Integer iInnerJoinComp
    Integer iTargetColumn
End_Struct

Struct tTQTableRelation
    Integer iTargetTable                  // The table that is being related to
    String sForceSQLTableName             // If represented in a select statement we can force its name by setting this
    _tTQTableRelationSegment[] aSegments  // The columns being used for the relation. Note that these may stem from a number of different
                                          // child tables. Note also that if aSegments is empty the record of the iTargetTable table is
                                          // constant for the duration of the query execution. But they are all in effect "outer left joins".
    Integer _iEmbeddedIndex               // What embedded index should be used to find a record of this kind (the iTargetTable kind)
    Boolean bFixed                        // A table is fixed if the record buffer is constant through the query.
    Boolean bInnerJoin                    // If a relation is marked as "inner join" the SQL generated will do something I can't remember.
End_Struct

Struct tTQOrderBySegment
    Boolean bDescending
    Integer bUppercase // -1:don't care 2:No 3:Yes
    _tTQValueSource stValueSource
End_Struct

Struct _tTQInnerJoinControlBlock
    Boolean bEnabled // Inner join enabled
    Boolean bInitialized // Inner join initialised
    String[] aCurrentParentSortValues // Sort values of current parent record
    Boolean bSkipNextFetch // First run in inner join
    Boolean bEndOfResultSet
End_Struct

Struct tTQPrefetchCacheControl
    Boolean bUseSettings
    Integer iPrefetchRecordCount
    Integer iPrefetchRecordTimeout
End_Struct

Struct tTSQueryControlBlock
    Boolean bCompiled
    Boolean bInitialized

    // How much do we prefer to limit the number of finds performed against the
    // database over not having to sort all the selected rows in an array?
    //
    // A value of 0.1 (its default value) indicates that we are willing to accept
    // 10 times more finds to not have to prefetch the whole set. A value of 1
    // would mean that we are not willing to perform any unnecessary finds and
    // thus prefetching would only occur if absolutely necessary.
    //
    // (actually it might make sense to set it according to the computing power or the
    // network speed of the client and the expected size of the result set)
    //
    // If set to a value greater than 1 prefetching will be preferred for no good
    // reason (so don't do that).

    Number nPrefetchAvoidanceFactor // Default assigned by NewQuery is 0.1

    Integer iFindCount
    Integer iSelectCount

    Boolean bFirstRecord
    
    String[] aOldBreakValues
    Integer iCurrentRecordBreakLevel //> Should be tested via the BreakLevel function. Should not be called unless bBreakLevelTest is set to true. (-1 means no break).

    Boolean bBreakScan
    String sLogTag

    Integer iCursor

    Boolean[] aRelatedRecords // True if the same index in the aTableRelations array has already been executed

    Integer iQueryMethod // tqDataFlex, tqSQLPKG or tqMERTECHINC
    tSQLStatementHandle stSQLStatementHandle
    Boolean bSQLTableIsAnsi
    tTQPrefetchCacheControl stSQLCacheControl
    tTQPrefetchCacheControl _stPreviousSQLCacheControl // Used to push the cache settings and restore previous value upon loop exit

    _tTQInnerJoinControlBlock stInnerJoinCB
End_Struct

Enum_List // Query methods
    Define tqDATAFLEX
    Define tqSQLPKG
    Define tqMERTECHINC
End_Enum_List

Struct tTSQueryCompiled
    Integer iIndex
    Boolean bBackwards

    Number nENR // Expected number of rows according to iIndex. If nENR is zero the index is fully specified

    Boolean bPrefetch
    Boolean bIndexSeedSharpeningEnabled
    Integer _iLimit
    Integer _iPushLimit
    tTQFilterSegment[] aJumpInValues
    tTQFilterSegment[] aJumpOutValues
    tTQFilterSegment[] aOtherConditions // Non optimized conditions
End_Struct

//> A value of this type is used with all calls to the TableQuery object (referenced as oTQ). You will never manipulate a tTableQuery
//> value by moving values directly into its members. You will instead call methods in the oTQ object to do so, in which case you
//> will pass a tTableQuery value by reference.
//>
//> But still, here is a peak into the representation of a tTableQuery value.
Struct tTableQuery
    Integer iTable             //> The main table of the query.

    Boolean bNoESQL            //> If true: Do not use ESQL even if SQL table.
    Boolean bForcePrefetch     //> If true: Force finding of all rows before FindRecord loop execution.
    Integer iForceIndex        //> If not -1: Force the table scanning to use that index (not relevant when ESQL).
    Integer iLimit             //> If not 0: Limits the amount of rows returned by the loop
    String  sForceSQLTableName //> Use this table name when generating ESQL (over the default value from filelist.cfg)
    String  sForceSQLStatement //> DANGER! Use this to completely overtake the SQL generated by TQ. It's your responsability then that the columns of the result set are in synch with what TQ expects (qua the result set specification).
    Boolean bBreakLevelTest    //> If true performs a break-level calculation for each record according to the current ordering.
    Boolean bRestoreRecordBuffersOnQueryCompletion //> If true: restore all involved record buffers on query completion.

// Select:
    //> If this array is empty TQ will by default activate the iTable buffer. Members are 
    //> added using AddResultColumn (and AddResultTable). The order of these may be change
    //> by TQ at will.
    //>
    //> When an item is added to aColumnSources that item is at the same time appended to 
    //> aOutputColumns.
    _tTQValueSource[]     aColumnSources 

    //> This array contains a copy of the items added to aColumnSources that are column specific. The 
    //> order of the columns will be identical to the order in which they were added
    _tTQValueSource[]     aOutputColumns 
    Boolean               _bOutputColumnsFixated // Set to true to avoid further items in aOutputColumns
    
    
// Where:
    tTQFilterSegment[] aFilters //> Segments are and'ed

// Order by:
    tTQOrderBySegment[]   aOrdering //> The ordering of the query

    // House keeping:
    tTSQueryCompiled      _stCompiled      //> Optimized information extracted from the above information
    tTSQueryControlBlock  _stControlBlock  //> Values that changes during the execution of the loop
    tTQResultSet          stResultSet      //> If this or that, this will contain the complete result set. Or just the values of the ordering columns. Or nothing.

    tTQTableRelation[]    aTableRelations //> Defines relations (joins) of the the query.
End_Struct

Struct _tTQIndexRating
    Integer iIndex
    Number  nExpectedNumberRows // With the filters supplied, how many rows can we expect to find by this index.
    Boolean bOutputAgree // Does the index agree with the output order specified?
    Integer iKeyLevels
    Integer iKeyLength // A short key length may rate better if everything else was equal.
End_Struct

Struct _tTQIndexAnalysis
    Number[] aSegmentReductions
End_Struct

Struct tTQTableAnalysis
    Boolean bInitialized
    DateTime dtAnalysisDateTime
    Number nNumberOfRecords
    _tTQIndexAnalysis[] aIndices
    String sTimeToComplete
End_Struct

Struct tTQTableMeta
    Integer   _iIsInitialized
    Integer[] aIndices // Indices to scan
End_Struct

Global_Variable tTQTableAnalysis[]  _gTQaTableAnalysis
Global_Variable tTQTableMeta[]      _gTQaTableMeta

Global_Variable Integer _giTQLogState // 0=No logging, 1=Log when LogTag'ed, 2=Log always
Global_Variable Integer[] _gaTQLogTables

Move 0 to _giTQLogState

Procedure Set TableQuery_LogState Global Integer iState
    Move iState to _giTQLogState
End_Procedure

// *******************************************************************
Class cTQExpressionParser is a cExpressionParser
    Procedure Construct_Object
        Forward Send Construct_Object
        Property Integer[] paAllowedTables // Tables allowed in expressions
    End_Procedure
    
    //> Augment to only allow table references aready accounted for in the stQ being handled
    Function OnTableNameToNumber String sLogicalName Returns Integer
        Integer iItem iMax iTable
        Integer[] aTables
        String sValue
        
        Move (Uppercase(sLogicalName)) to sLogicalName
        
        Get paAllowedTables to aTables
        Move (SizeOfArray(aTables)-1) to iMax
        
        For iItem from 0 to iMax 
            Move aTables[iItem] to iTable
            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
            If (sLogicalName=Uppercase(sValue)) Begin
                Function_Return iTable
            End
        Loop
        Function_Return -1
    End_Function
    
    //> Parameter aContext_opt (if there) will be passed to OnGetSymbolNameIsLegal
    Function TokenizeString tXPGrammar stGrammar String sExpression tXPError ByRef stError Variant[] aContext_opt Returns tXPToken[]
        Integer iItem iMax
        tXPToken[] aSymbols
        tXPToken stSymbol
        Variant[] aContext

        If (num_arguments>3) Begin
            Move aContext_opt to aContext
        End
        
        Forward Get TokenizeString stGrammar sExpression (&stError) aContext to aSymbols
        
        If (stError.sErrorText="") Begin
            // Go through and check that no symbols are un-resolved
            Move (SizeOfArray(aSymbols)-1) to iMax
            For iItem from 0 to iMax
                Move aSymbols[iItem] to stSymbol
                If (stSymbol.iType=XPTokenType_Symbol) Begin
                    If (stSymbol.stValueHint.iTable=0 and stSymbol.stValueHint.iConstantIndex=-1 and not(OnGetSymbolNameIsLegal(Self,stSymbol,aContext))) Begin
                        Send _RegisterError (&stError) stSymbol.iStartPos ("Symbol not recognised: "+stSymbol.sValue)
                    End
                End
            Loop
        End
        Function_Return aSymbols
    End_Function
    
End_Class

//Class _cTQExpressionParser is a cTQExpressionParser
//    Procedure OnDefineFunctions tXPGrammar ByRef stGrammar
//        Send DefineFunction (&stGrammar) "IIF"        3 XP_String  (RefFunc(_fIf)) // intermediate-if
//    End_Procedure
//End_Class

// *******************************************************************

Use cSqlStatementBuilder.pkg

Class cTableQuerySqlBuilder is a cSqlStatementBuilder // Generates an SQL statement

        Procedure _AddSqlColumns tTableQuery stQ tSqlStmt ByRef stStmt 
            Integer iMax iItem iTable iColumn
            Integer iFieldType iLength
            String sColumnName sTableName
            
            Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
            If (iMax>=0) Begin
                For iItem from 0 to iMax
                    Move stQ.aColumnSources[iItem].iTable to iTable
                    Move stQ.aColumnSources[iItem].iColumn to iColumn
                    
                    If (iTable>0) Begin // Tt's not an expression

                        If (iColumn<>0) Begin
                            Send AddStmtColumn (&stStmt) iTable iColumn
                        End
                        Else Begin
                            Get SqlTableName iTable to sTableName
                            Move (sTableName+".*") to sColumnName
                            Send AddStmtColumnExpr (&stStmt) sColumnName
                        End
                    End
                    Else If (SizeOfArray(stQ.aColumnSources[iItem].aSymbols)>0) Begin 
// ToDo: Generate SQL for expression                
//                        Move stQ.aColumnSources[iItem].sConstant to sColumnName
//                        Get _SQL_Expression stQ hoTQ sColumnName to sColumnName
                    End
                Loop
            End
            Else Begin
                Send AddStmtColumnExpr (&stStmt) "*"
            End
        End_Procedure

            Function _TQCompToSqlComp Integer iTQComp Returns String
                If (iTQComp=tqLT) Begin
                    Function_Return "<"
                End
                If (iTQComp=tqLE) Begin
                    Function_Return "<="
                End
                If (iTQComp=tqEQ) Begin
                    Function_Return "="
                End
                If (iTQComp=tqGE) Begin
                    Function_Return ">="
                End
                If (iTQComp=tqGT) Begin
                    Function_Return ">"
                End
                If (iTQComp=tqNE) Begin
                    Function_Return "<>"
                End
                If (iTQComp=tqMATCH) Begin
                    Function_Return "like" // This can't be guaranteed on SQL. or what?
                End
                If (iTQComp=tqUCMATCH) Begin
                    Function_Return "like"
                End
                Function_Return ("err")
            End_Function
            
            Function _TQTypeToSqlType Integer iTQType Returns Integer 
                If (iTQType=tqSTRING) Begin
                    Function_Return typeString
                End
                If (iTQType=tqNUMBER) Begin  
                    Function_Return typeNumber
                End                    
                If (iTQType=tqTEXT) Begin    
                    Function_Return typeString
                End
                If (iTQType=tqDATE) Begin
                    Function_Return typeDate
                End
                If (iTQType=tqDATETIME) Begin
                    Function_Return typeDateTime
                End
                Function_Return typeString
            End_Function

            Procedure _AddSqlFilterSegment tTableQuery stQ tSqlStmt ByRef stStmt Integer iFilterIndex
                Integer iTable iColumn iSqlType 
                String sSqlArray sFilter
                String[] aOperands
                tTQFilterSegment stFilterSegment

                Move stQ.aFilters[iFilterIndex] to stFilterSegment
                
                If (SizeOfArray(stFilterSegment.stRightValue.aSymbols)>0) Begin // It's an expression
                    // ToDo: Handle expressions
//                    Get _SQL_WhereClauseExpressionSegment stQ stFilterSegment hoTQ to sValue
                End
                Else Begin
                    Move stFilterSegment.stLeftValue.iTable to iTable
                    Move stFilterSegment.stLeftValue.iColumn to iColumn
                    
                    If ((stFilterSegment.iComp=tqEQ or stFilterSegment.iComp=tqNE) and SizeOfArray(stFilterSegment.stRightValue.aOrList)<>0) Begin
                        // It's 'in' or 'not in'
                        Get _TQTypeToSqlType stFilterSegment.stLeftValue.iType to iSqlType
                        Get SqlArray stFilterSegment.stRightValue.aOrList iSqlType to sSqlArray
                    
                        Send AddStmtFilterExpr (&stStmt) iTable iColumn "in"
                        Get SqlFilterColumnExpr iTable iColumn "in" sSqlArray to sFilter
                            
                        If (stFilterSegment.iComp=tqNE) Begin // not in => flip the filter
                            Send PushOperandExpr (&aOperands) sFilter
                            Send ApplyOperator (&aOperands) "not"
                            Get TopOperand aOperands to sFilter
                        End
                        
                        Send AddStmtFilterExpr (&stStmt) sFilter
                    End
                    Else Begin
                        Send AddStmtFilter (&stStmt) iTable iColumn (_TQCompToSqlComp(Self,stFilterSegment.iComp)) stFilterSegment.stRightValue.sConstant
                    End
                End
            End_Procedure
            
        Procedure _AddSqlFilters tTableQuery stQ tSqlStmt ByRef stStmt
            Integer iMax iItem
            String sValue
            Move (SizeOfArray(stQ.aFilters)-1) to iMax
            For iItem from 0 to iMax
                Send _AddSqlFilterSegment stQ (&stStmt) iItem
            Loop
            Function_Return sValue
        End_Procedure

        Procedure _AddSqlJoins tTableQuery stQ tSqlStmt ByRef stStmt
            Integer iItem iMax
            Integer iSegment iSegmentMax
            String sFromTables sTableName

            Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
            For iItem from 0 to iMax
                If (not(stQ.aTableRelations[iItem].bFixed)) Begin
                    Send AddStmtJoin (&stStmt) (SqlTableName(Self,stQ.aTableRelations[iItem].iTargetTable)) C_SQL_LEFT_JOIN
                    Move (SizeOfArray(stQ.aTableRelations[iItem].aSegments)-1) to iSegmentMax
                    For iSegment from 0 to iSegmentMax
                        Send AddStmtJoinSegment (&stStmt) stQ.aTableRelations[iItem].aSegments[iSegment].iSourceTable stQ.aTableRelations[iItem].aSegments[iSegment].iSourceColumn stQ.aTableRelations[iItem].iTargetTable stQ.aTableRelations[iItem].aSegments[iSegment].iTargetColumn
                    Loop
                End
            Loop
            Function_Return sFromTables
        End_Procedure

        Procedure _AddSqlOrder tTableQuery stQ tSqlStmt ByRef stStmt
            Integer iItem iMax iTable iColumn
            String sValue sColumnName
            Move (SizeOfArray(stQ.aOrdering)-1) to iMax
            For iItem from 0 to iMax
                
                // OBS! Here we need expression handling
                
                Move stQ.aOrdering[iItem].stValueSource.iTable to iTable
                Move stQ.aOrdering[iItem].stValueSource.iColumn to iColumn
                Send AddStmtOrderBy (&stStmt) iTable iColumn stQ.aOrdering[iItem].bDescending
//
//                Move (sValue+sColumnName) to sValue
//                If (stQ.aOrdering[iItem].stValueSource.iType=tqSTRING) Begin
//                    Move (sValue+" collate "+psCollation(Self)) to sValue
//                End
//                If (stQ.aOrdering[iItem].bDescending) Begin
//                    Move (sValue*"DESC") to sValue
//                End
                // ToDo: uppercase ordering
//                If (stQ.aOrdering[iItem].bUppercase=1) Begin
//                    // Somethings wrong here. And it's not the 'lower' instead of 'upper'
//                    Move (sValue*"lower("+sValue+")") to sValue
//                End
            Loop
        End_Procedure
        
    Function TableQueryToStmt tTableQuery stQ Returns tSqlStmt
        Integer iItem iMax
        tSqlStmt stStmt
        
        Get NewStmt (SqlTableName(Self,stQ.iTable)) to stStmt

        If (stQ.iLimit>0) Begin
            Move stQ.iLimit to stStmt.iTop
        End
        If (stQ.iLimit<0) Begin
            Error DFERR_PROGRAM "Table query can not handle negative 'top' setting"
        End

        Send _AddSqlJoins stQ (&stStmt)
        Send _AddSqlColumns stQ (&stStmt)
        Send _AddSqlFilters stQ (&stStmt)
        Send _AddSqlOrder stQ (&stStmt)
//
//        Move (sStatement*_SQL_SelectColumns(Self,stQ,hoTQ)) to sStatement
        
        Function_Return stStmt
    End_Function

    Function TableQuerySelectStatement tTableQuery stQ Returns String
        String sSql
        tSqlStmt stStmt
        Get TableQueryToStmt stQ to stStmt
        Get StmtToString stStmt to sSql
        Function_Return sSql
    End_Function
End_Class

//Class cTableQuerySQL is a cObject // Generates an SQL statement
//    Procedure Construct_Object
//        Forward Send Construct_Object
//        Property String psCollation "Latin1_General_BIN" // Or maybe "SQL_Latin1_CP850_BIN"? Who knows?
//    End_Procedure
//
//        Function _SQL_ColumnName tTableQuery stQ Integer hoTQ Integer iTable Integer iColumn Returns String
//            String sValue
//            Get ColumnName of hoTQ stQ iTable iColumn True to sValue
//            Function_Return sValue
//        End_Function
//
//        Function _SQL_TableName tTableQuery stQ Integer hoTQ Integer iTable Returns String
//            String sValue
//            Get TableName of hoTQ stQ iTable to sValue
//            Move ("["+sValue+"]") to sValue
//            Function_Return sValue
//        End_Function
//        
//                    Function _SQL_EscapeQuote String sValue Returns String
//                        Function_Return (Replaces("'",sValue,"char(39)"))
//                    End_Function
//                
//                Function _SQL_ExpressionToken tTableQuery stQ Integer hoTQ tXPGrammar stGrammar tXPToken stToken Boolean ByRef bError Returns String
//                    Move False to bError
//                    String sValue
//                    If (stToken.iType=XPTokenType_Error) Begin
//                        Move True to bError
//                        Function_Return ""
//                    End
//                    Else If (stToken.iType=XPTokenType_Operator) Begin
//                        Function_Return stGrammar.aOperators[stToken.iOperatorIndex].sSymbol
//                    End
//                    Else If (stToken.iType=XPTokenType_Symbol) Begin
//                        Function_Return stToken.sValue
//                    End
//                    Else If (stToken.iType=XPTokenType_FunctionCall) Begin
//                        Function_Return stGrammar.aFunctions[stToken.iOperatorIndex].sFunction
//                    End
//                    Else If (stToken.iType=XPTokenType_NewParameter) Begin
//                        Function_Return ","
//                    End
//                    Else If (stToken.iType=XPTokenType_EndFunctionCall) Begin
//                        Function_Return ")"
//                    End
//                    Else If (stToken.iType=XPTokenType_StringConstant) Begin
//                        Get _SQL_EscapeQuote stToken.sValue to sValue
//                        Function_Return ("'"+sValue+"'")
//                    End
//                    Else If (stToken.iType=XPTokenType_NumberConstant) Begin
//                        Function_Return stToken.sValue
//                    End
//                    Else If (stToken.iType=XPTokenType_IntegerConstant) Begin
//                        Function_Return stToken.sValue
//                    End
//                    Else If (stToken.iType=XPTokenType_LeftParenthesis) Begin
//                        Function_Return "("
//                    End
//                    Else If (stToken.iType=XPTokenType_RightParenthesis) Begin
//                        Function_Return ")"
//                    End
//                    Move True to bError
//                    Function_Return ""
//                End_Function
//            
//            Function _SQL_Expression tTableQuery stQ Integer hoTQ String sExpression Returns String
//                Boolean bError
//                Integer iMax iItem
//                Integer hoExprParser
//                Integer[] aLegalTables // For expressions
//                String sSqlExpr sAtom
//                tXPGrammar stGrammar
//                tXPError stError
//                tXPToken[] aSymbols
//                
//                Get phoExprParser to hoExprParser
//                
//                Get LegalExpressionTables stQ to aLegalTables
//                Set paAllowedTables of hoExprParser to aLegalTables
//                
//                Get NewGrammar of hoExprParser to stGrammar
//                Get TokenizeString of hoExprParser stGrammar sExpression (&stError) to aSymbols
//                
//                If (stError.sErrorText="" and SizeOfArray(aSymbols)>0) Begin
//                    Move "" to sSqlExpr
//                    Move (SizeOfArray(aSymbols)-1) to iMax
//                    
//                    For iItem from 0 to iMax
//                        Get _SQL_ExpressionToken stQ hoTQ stGrammar aSymbols[iItem] (&bError) to sAtom
//                        If (not(bError)) Begin
//                            Move (sSqlExpr+sAtom) to sSqlExpr
//                        End
//                        Else Begin
//                            Function_Return "expression-error"
//                        End
//                    Loop
//                    Function_Return sSqlExpr
//                End
//                Function_Return "expression-error"
//            End_Function
//
//        Function _SQL_SelectColumns tTableQuery stQ Integer hoTQ Returns String
//            Integer iMax iItem iTable iColumn
//            Integer iFieldType iLength
//            String sColumnList sColumnName sTableName
//            Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
//            If (iMax>=0) Begin
//                For iItem from 0 to iMax
//                    Move stQ.aColumnSources[iItem].iTable to iTable
//                    Move stQ.aColumnSources[iItem].iColumn to iColumn
//                    
//                    If (iTable>0) Begin // Tt's not an expression
//                        If (iItem<>0) Begin
//                            Move (sColumnList+",") to sColumnList
//                        End
//    
//                        If (iColumn<>0) Begin
//                            Get _SQL_ColumnName stQ hoTQ iTable iColumn to sColumnName
//                            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iFieldType
//                            If (iFieldType=DF_TEXT) Begin
//                                Get_Attribute DF_FIELD_NATIVE_LENGTH of iTable iColumn to iLength
//                                If (iLength>8000) Begin
//                                    Move ("LEFT("+sColumnName+",20)") to sColumnName
//                                End
//                            End
//                        End
//                        Else Begin
//                            Get TableName of hoTQ stQ iTable to sTableName
//                            Move (sTableName+".*") to sColumnName
//                        End
//                        Move (sColumnList+sColumnName) to sColumnList
//                    End
//                    Else If (SizeOfArray(stQ.aColumnSources[iItem].aSymbols)>0) Begin 
//                        // It is an expression
//                        If (iItem<>0) Begin
//                            Move (sColumnList+",") to sColumnList
//                        End
//
//                        Move stQ.aColumnSources[iItem].sConstant to sColumnName
//                        Get _SQL_Expression stQ hoTQ sColumnName to sColumnName
//                        Move (sColumnList+sColumnName) to sColumnList
//                    End
//                Loop
//            End
//            Else Begin
//                Move "*" to sColumnList
//            End
//            Function_Return sColumnList
//        End_Function
//
//            Procedure _SQL_OuterLeftJoin_AddSegments tTableQuery stQ Integer hoTQ String ByRef sFromTables Integer iRelateItem
//                Integer iItem iItemMax
//                String sColumnName sComp
//                tTQTableRelation strRelation
//                Move stQ.aTableRelations[iRelateItem] to strRelation
//                Move (SizeOfArray(strRelation.aSegments)-1) to iItemMax
//                For iItem from 0 to iItemMax
//                    If (iItem<>0) Begin
//                        Move (sFromTables+" AND") to sFromTables
//                    End
//                    Get _SQL_ColumnName stQ hoTQ strRelation.aSegments[iItem].iSourceTable strRelation.aSegments[iItem].iSourceColumn to sColumnName
//                    Move (sFromTables*sColumnName) to sFromTables
//
//                    Get _SQL_WhereClauseComperator strRelation.aSegments[iItem].iInnerJoinComp False False to sComp
//                    Move (sFromTables*sComp) to sFromTables
//
//                    Get _SQL_ColumnName stQ hoTQ strRelation.iTargetTable strRelation.aSegments[iItem].iTargetColumn to sColumnName
//                    Move (sFromTables*sColumnName) to sFromTables
//                Loop
//            End_Procedure
//
//            //select f.foo
//            //     , b.bar
//            //     , q.qux
//            //  from footable as f
//            //left outer
//            //  join bartable as b
//            //    on f.id = b.fid
//            //left outer
//            //  join quxtable as q
//            //    on b.id = q.bid
//
//        Function _SQL_OuterLeftJoins tTableQuery stQ Integer hoTQ Returns String
//            Integer iItem iItemMax
//            String sFromTables sTableName
//            Get TableName of hoTQ stQ stQ.iTable to sFromTables
//
//            Move (SizeOfArray(stQ.aTableRelations)-1) to iItemMax
//            For iItem from 0 to iItemMax
//                If (not(stQ.aTableRelations[iItem].bFixed)) Begin
//                    Get _SQL_TableName stQ hoTQ stQ.aTableRelations[iItem].iTargetTable to sTableName
//                    Move (sFromTables+" left outer join"*sTableName+" on (") to sFromTables
//                    Send _SQL_OuterLeftJoin_AddSegments stQ hoTQ (&sFromTables) iItem
//                    Move (sFromTables+")") to sFromTables
//                End
//            Loop
//            Function_Return sFromTables
//        End_Function
//
//        Function _SQL_InnerJoins tTableQuery stQ Integer hoTQ Returns String
//            Integer iItem iItemMax
//            String sFromTables sTableName
//
//            Move (SizeOfArray(stQ.aTableRelations)-1) to iItemMax
//            For iItem from 0 to iItemMax
//                If (stQ.aTableRelations[iItem].bInnerJoin) Begin
//                    Get _SQL_TableName stQ hoTQ stQ.aTableRelations[iItem].iTargetTable to sTableName
//                    Move (sFromTables+" inner join"*sTableName+" on (") to sFromTables
//                    Send _SQL_OuterLeftJoin_AddSegments stQ hoTQ (&sFromTables) iItem
//                    Move (sFromTables+")") to sFromTables
//                End
//            Loop
//            Function_Return sFromTables
//        End_Function
//
//            Function _SQL_WhereClauseComperator Integer iComp Boolean bIn Boolean bNotIn Returns String
//                If (bIn) Begin
//                    Function_Return " in "
//                End
//                If (bNotIn) Begin
//                    Function_Return " not in "
//                End
//                If (iComp=tqLT) Begin
//                    Function_Return "<"
//                End
//                If (iComp=tqLE) Begin
//                    Function_Return "<="
//                End
//                If (iComp=tqEQ) Begin
//                    Function_Return "="
//                End
//                If (iComp=tqGE) Begin
//                    Function_Return ">="
//                End
//                If (iComp=tqGT) Begin
//                    Function_Return ">"
//                End
//                If (iComp=tqNE) Begin
//                    Function_Return "<>"
//                End
//                If (iComp=tqMATCH) Begin
//                    Function_Return " like " // This can't be guaranteed on SQL. or what?
//                End
//                If (iComp=tqUCMATCH) Begin
//                    Function_Return " like "
//                End
////                If (iComp=tqCONTAINS) Function_Return "contains"
//                Function_Return "error"
//            End_Function
//
//                Function EscapeStringConstant String sValue Returns String
//                    Function_Return (Replaces("'",sValue,"''")) // cross fingers
//                End_Function
//
//            Function _SQL_WhereClauseValue tTableQuery stQ Integer hoTQ Integer iComp _tTQValueSource stValue Returns String
//                // This function may not be called with SizeOfArray(stValue.aSymbols)>0
//                Boolean bFixed bDoValue
//                Integer iMax iItem
//                String sValue sColumnName sSQLdate
//                
//                If (iComp=tqEQ and SizeOfArray(stValue.aOrList)<>0) Begin // IN LIST
//                    Move (SizeOfArray(stValue.aOrList)-1) to iMax
//                    Move "(" to sValue
//                    For iItem from 0 to iMax
//
//                        If (iItem>0) Begin
//                            Move (sValue+",") to sValue
//                        End
//
//                        If (stValue.iType=tqSTRING or stValue.iType=tqTEXT) Begin
//                            Move (sValue+"'"+EscapeStringConstant(Self,stValue.aOrList[iItem])+"'") to sValue
//                        End
//                        Else If (stValue.iType=tqDATE or stValue.iType=tqDATETIME) Begin
//                            Get DFDateToSQLDate of stQ._stControlBlock.stSQLStatementHandle.hStatHandle (Date(stValue.aOrList[iItem])) to sSQLdate
//                            Move (sValue+"'"+sSQLdate+"'") to sValue
//                        End
//                        Else Begin
//                            Move (sValue+stValue.aOrList[iItem]) to sValue
//                        End
//                    Loop
//                    Move (sValue+")") to sValue
//                End
//                Else If (iComp=tqNE and SizeOfArray(stValue.aOrList)<>0) Begin // NOT IN LIST
//                    // NOT IN 
//                    Error DFERR_PROGRAM "Missing handler for not-in-list"
//                    // MUST BE IMPLEMENTET
//                End
//                Else Begin
//                    Move True to bDoValue
//                    If (stValue.iTable<>0) Begin
//                        Get _IsTableFixed of hoTQ stQ stValue.iTable to bFixed
//                        If (not(bFixed)) Begin
//                            Get _SQL_ColumnName stQ hoTQ stValue.iTable stValue.iColumn to sColumnName
//                            Move sColumnName to sValue
//                            Move False to bDoValue
//                        End
//                    End
//                    If (bDoValue) Begin // Either it's a constant or it's a fixed table:
//                        Get _ValueSourceValue of hoTQ (&stQ) stValue to sValue
//
//                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
//                            Move (Replaces("%",sValue,"\%")) to sValue // Escape all SQL wildcard patterns
//                            Move (Replaces("_",sValue,"\_")) to sValue // that happens to be in the string
//                            Move (Replaces("[",sValue,"\[")) to sValue // by chance.
//                            Move (Replaces("]",sValue,"\]")) to sValue
//                            Move (Replaces("*",sValue,"%")) to sValue  // Replace our own * and ? wildcards
//                            Move (Replaces("?",sValue,"_")) to sValue  // with their SQL counterparts.
//                            If (iComp=tqUCMATCH) Begin
//                                Move (Uppercase(sValue)) to sValue
//                            End
//                        End
//
//                        If (stValue.iType=tqSTRING or stValue.iType=tqTEXT) Begin
//                            Move ("'"+EscapeStringConstant(Self,sValue)+"'") to sValue
//                        End
//                        Else If (stValue.iType=tqDATE or stValue.iType=tqDATETIME) Begin
//                            Get DFDateToSQLDate of stQ._stControlBlock.stSQLStatementHandle.hStatHandle (Date(sValue)) to sValue
//                            Move ("'"+sValue+"'") to sValue
//                        End
//
//                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
//                            Move (sValue*"ESCAPE '\'") to sValue // tell mssql that the pattern has been escaped with the "\" character.
//                        End
//                    End
//                End
//                Function_Return sValue
//            End_Function
//            
//                Function _SQL_WhereClauseExpressionSegment tTableQuery stQ tTQFilterSegment stSegment Integer hoTQ Returns String
//                    Integer iItem iMax
//                    Integer hoExprParser
//                    Integer[] aLegalTables // For expressions
//                    tXPGrammar stGrammar
//                    tXPError stError
//                    tXPToken[] aSymbols
//                    String sSqlExpr sColumName sValue
//                    
//                    Get phoExprParser to hoExprParser
//                    
//                    Get LegalExpressionTables stQ to aLegalTables
//                    Set paAllowedTables of hoExprParser to aLegalTables
//                    
//                    Get NewGrammar of hoExprParser to stGrammar
//                    Get TokenizeString of hoExprParser stGrammar stSegment.stRightValue.sConstant (&stError) to aSymbols
//                    
//                    Move (SizeOfArray(aSymbols)-1) to iMax
//                    For iItem from 0 to iMax
//                        // If it's a table.column
//                        If (aSymbols[iItem].iType=XPTokenType_Symbol and aSymbols[iItem].stValueHint.iTable<>0) Begin
//                            Get _SQL_ColumnName stQ hoTQ aSymbols[iItem].stValueHint.iTable aSymbols[iItem].stValueHint.iColumn to sColumName
//                            Move (sSqlExpr*sColumName) to sSqlExpr
//                        End
//                        Else If (aSymbols[iItem].iType=XPTokenType_StringConstant) Begin // If it's a string constant    
//
//                            Move ("'"+EscapeStringConstant(Self,aSymbols[iItem].sValue)+"'") to sValue
//                            Move (sSqlExpr*sValue) to sSqlExpr
//                        End
//                        Else Begin
//                            Move (sSqlExpr*aSymbols[iItem].sValue) to sSqlExpr
//                        End
//                    Loop
//                    
//                    Function_Return ("("+sSqlExpr+")")
//                End_Function
//
//            Function _SQL_WhereClauseSegment tTableQuery stQ tTQFilterSegment stSegment Integer hoTQ Returns String
//                Integer iTable iColumn
//                Boolean bIn bNotIn
//                String sValue
//                
//                If (SizeOfArray(stSegment.stRightValue.aSymbols)>0) Begin // It's an expression
//                    Get _SQL_WhereClauseExpressionSegment stQ stSegment hoTQ to sValue
//                End
//                Else Begin
//                    Move stSegment.stLeftValue.iTable to iTable
//                    Move stSegment.stLeftValue.iColumn to iColumn
//                    Get _SQL_ColumnName stQ hoTQ iTable iColumn to sValue
//    
//                    If (stSegment.iComp=tqEQ) Begin
//                        Move (SizeOfArray(stSegment.stRightValue.aOrList)<>0) to bIn
//                        Move (sValue+_SQL_WhereClauseComperator(Self,stSegment.iComp,bIn,False)) to sValue
//                    End
//                    If (stSegment.iComp=tqNE) Begin
//                        Move (SizeOfArray(stSegment.stRightValue.aOrList)<>0) to bNotIn
//                        Move (sValue+_SQL_WhereClauseComperator(Self,stSegment.iComp,False,bNotIn)) to sValue
//                    End
//
//                    Move (sValue+_SQL_WhereClauseValue(Self,stQ,hoTQ,stSegment.iComp,stSegment.stRightValue)) to sValue
//                End
//
//                Function_Return sValue
//            End_Function
//
//        Function _SQL_WhereClause tTableQuery stQ Integer hoTQ Returns String
//            Integer iMax iItem
//            Boolean bAddAND
//            String sValue
//            Move (SizeOfArray(stQ.aFilters)-1) to iMax
//// ToDo: This needs to take care of expressions someday
//            For iItem from 0 to iMax
//                If (iItem<>0) Begin
//                    Move (sValue*"and") to sValue
//                End
//                Move (sValue*_SQL_WhereClauseSegment(Self,stQ,stQ.aFilters[iItem],hoTQ)) to sValue
//            Loop
//            Function_Return sValue
//        End_Function
//
//        Function _SQL_OrderByClause tTableQuery stQ Integer hoTQ Returns String
//            Integer iItem iMax iTable iColumn
//            String sValue sColumnName
//            Move (SizeOfArray(stQ.aOrdering)-1) to iMax
//            For iItem from 0 to iMax
//                If (iItem<>0) Begin
//                    Move (sValue+", ") to sValue
//                End
//                
//                // OBS! Here we need expression handling
//                
//                Move stQ.aOrdering[iItem].stValueSource.iTable to iTable
//                Move stQ.aOrdering[iItem].stValueSource.iColumn to iColumn
//                Get _SQL_ColumnName stQ hoTQ iTable iColumn to sColumnName
//                Move (sValue+sColumnName) to sValue
//                If (stQ.aOrdering[iItem].stValueSource.iType=tqSTRING) Begin
//                    Move (sValue+" collate "+psCollation(Self)) to sValue
//                End
//                If (stQ.aOrdering[iItem].bDescending) Begin
//                    Move (sValue*"DESC") to sValue
//                End
//                // ToDo: uppercase ordering
////                If (stQ.aOrdering[iItem].bUppercase=1) Begin
////                    // Somethings wrong here. And it's not the 'lower' instead of 'upper'
////                    Move (sValue*"lower("+sValue+")") to sValue
////                End
//            Loop
//            Function_Return sValue
//        End_Function
//
//    Function _SQLSelectStatement tTableQuery stQ Integer hoTQ Returns String
//        String sStatement
//
//        Move "select" to sStatement
//
//        If (stQ.iLimit>0) Begin
//            Move (sStatement*"top "+String(stQ.iLimit)) to sStatement
//        End
//        If (stQ.iLimit<0) Begin
//            Move (sStatement*"bottom "+String(0-stQ.iLimit)) to sStatement
//        End
//
//        Move (sStatement*_SQL_SelectColumns(Self,stQ,hoTQ)) to sStatement
//
//        Move (sStatement*" from") to sStatement
//
//        Move (sStatement*_SQL_OuterLeftJoins(Self,stQ,hoTQ)) to sStatement // related records
//
//        Move (sStatement*_SQL_InnerJoins(Self,stQ,hoTQ)) to sStatement // find child records for each parent
//
//        If (SizeOfArray(stQ.aFilters)<>0) Begin
//            Move (sStatement*" where") to sStatement
//            Move (sStatement*_SQL_WhereClause(Self,stQ,hoTQ)) to sStatement
//        End
//        If (SizeOfArray(stQ.aOrdering)<>0) Begin
//            Move (sStatement*" order by") to sStatement
//            Move (sStatement*_SQL_OrderByClause(Self,stQ,hoTQ)) to sStatement
//        End
//        Function_Return sStatement
//    End_Function
//
//    Function _SQLDeleteStatement tTableQuery stQ Integer hoTQ Returns String
//        String sStatement
//
//        Move "delete" to sStatement
//
////        If (stQ.iLimit<>0) Begin
////            Send OnError 742 "Limit not allowed on delete statement"
////            Function_Return "" // Error
////        End
////
////        If (SizeOfArray(stQ.aColumnSources)>0) Begin
////            Send OnError 743 "Result column not allowed on delete statement"
////            Function_Return "" // Error
////        End
//
//        Move (sStatement*" from") to sStatement
//
//        Move (sStatement*_SQL_OuterLeftJoins(Self,stQ,hoTQ)) to sStatement // related records
//
//        Move (sStatement*_SQL_InnerJoins(Self,stQ,hoTQ)) to sStatement // find child records for each parent
//
//        If (SizeOfArray(stQ.aFilters)<>0) Begin
//            Move (sStatement*" where") to sStatement
//            Move (sStatement*_SQL_WhereClause(Self,stQ,hoTQ)) to sStatement
//        End
//
////        If (SizeOfArray(stQ.aOrdering)>0) Begin
////            Send OnError 744 "Ordering not allowed on delete statement"
////            Function_Return "" // Error
////        End
//
//        Function_Return sStatement
//    End_Function
//End_Class

//> Class cTableQueryFunctions is the superclass of global object oTQ
Class cTableQueryFunctions is a cObject

    Procedure Construct_Object
        Forward Send Construct_Object

        Property Number _pnPrefetchAvoidanceFactor // Temporary property used by index rating sort algorithm

        Object _oSqlBuilder is a cTableQuerySqlBuilder
            Send DefineOperators 
        End_Object
        
        
        Object _oExprParser is a cTQExpressionParser
        End_Object
        
        Property Integer phoExprParser (_oExprParser(Self))
        Property Handle phoSqlBuilder (_oSqlBuilder(Self))
        Property tTQOrderBySegment[] _paOrderingTmp
                
    End_Procedure

    Function Version Returns String
// Function_Return "0.96" // 9-05-2012
        // Fixed error in MSSQLDRV SQL generating when an ordering segment is both ASCII and descending
        // Removed timing and track of current-record
// Function_Return "0.97" // 10-05-2012
        // Addded methods ResetResultSetColumns and ResetOrdering
        // Fixed seeding error on backwards ASCII columns
        // Bug in ResultColumnValue function fixed
        // Bug in _FindFirstRecordAux function fixed (related to 'VFind GE')
        // SQL handling of dates repaired
        // Parent column filter bugfix. No longer ends up in jump-in/out filters by accident
        // Fixed _ValidateQuery to correctly complain about over-constrain on parent table columns
        // Public function SQLStatement renamed to SQLSelectStatement
// Function_Return "0.98" // 29-11-2012
        // SQL date handling is now also effective if column type is DF_DATETIME (may go wrong if value also has a time part)
        // Implementation of private function _DeleteConstraint changed (old one still there for 15.1)
        // Method DeleteRecords added (ignore, not tested)
// Function_Return "0.99" // 04-04-2013
        // Fixed bug in AddFilterTableColumn method.
        // Comperators tqCONTAINS and tqIN have been removed.
        // Filter evaluating for index seeding capacitance has been fixed. Until now filters on parent tables may have wronged the index selection process.
        // Error handling changed. All errors are now declared as DFERR_PROGRAM. If cTableQueryFunctions is subclassed procedure OnError may be augmented to do otherwise.
        // Function HasData was designed to check for data before the main finding loop was entered. It may now also meaningfully be called after the main loop to query if the loop had any data at all.
        // Function FixedTables added. Returns an array of tables that are referenced as "fixed" during the execution of a query. So if I want to repeat the find loop of a particular tTableQuery variable at a later time, the record buffers of these fixed tables must be restored to that of the original query. Does this make sense?
        // Similarly NotFixedTables has been added.
        // Function Belongs added. Returns true if the record currently in the buffer of the query main table evaluates true against the filters of query variable passed.
        // Procedure RestoreRecordBuffersOnQueryCompletion added. Use to have TQ restore all affected record buffers on find loop completion.
// Function_Return "0.991" // 25-09-2013
        // 2015-12-09 Fixed a problem with iFailedConstrainIndex in function _FindFirstRecordAux
        //Function_Return "0.998" // 16-02-2016
        // 2017-01-11 Fixed _SharpenJumpInValue problem (DateTime error)
        // 2017-10-12 Jakob Kruse fixed an error in AddFilterRelateFixedRecord
        // 2017-10-13 Existing expressions have been taken out
        // 2017-12-19 Added SetBreakLevelTest
        // 2018-01-31 Fixed bind recordbuffer issue when ESQL
        // 2018-10-24 Added AddFilterNotInList and renamed AddFilterInList to AddFilterInList
        // Function_Return "0.999" // 24-10-2018
        // 11-10-2023 Fixed custom sorting for UTF-8 versions of DataFlex
        // 11-10-2023 SQL builder reworked
        // 11-10-2023 Method DeleteRecords removed
        // 01-11-2023 Fixed case insensitive index handling
        Function_Return "0.9991" // 11-10-2023
    End_Function

    //> This is how to initiate a new tTableQuery variable. Every query starts is life by you calling this functions.
    Function NewQuery Integer iTable Returns tTableQuery
        Integer iFilterTable iArg
        tTableQuery stQ
        Move iTable to stQ.iTable
        Move -1     to stQ.iForceIndex
        Move False  to stQ.bForcePrefetch
        Move False  to stQ.bNoESQL
        Move False  to stQ.bRestoreRecordBuffersOnQueryCompletion
        Move False  to stQ.bBreakLevelTest
        Move False  to stQ._stControlBlock.bInitialized
        Move False  to stQ._stControlBlock.bCompiled
        Move -1     to stQ._stControlBlock.iQueryMethod
        Move 0.1    to stQ._stControlBlock.nPrefetchAvoidanceFactor
        Move False  to stQ._stControlBlock.stInnerJoinCB.bEnabled // (CB=Control Block)
        Move False  to stQ._stControlBlock.stInnerJoinCB.bInitialized
//        Move False  to stQ._stControlBlock.bFilterExpressionActive
        Move True   to stQ._stCompiled.bIndexSeedSharpeningEnabled
        Move False  to stQ._stCompiled.bBackwards
        Move -1     to stQ._stCompiled.nENR
        Move False  to stQ._bOutputColumnsFixated
        Send ReadTableDefinition of oOverlapColumnFunctions iTable // Make sure that oOverlapColumnFunctions knows about this table
        If (num_arguments>1) Begin // For a while multiple parameters was allowed. Therefore this. Also for a while.
            Error 343 "TQ: Illegal call to NewQuery"
        End
        Function_Return stQ
    End_Function

    Procedure OnError Integer iErrNo String sErrorText
        Error DFERR_PROGRAM ("TQ-"+String(iErrNo)+": "+sErrorText)
    End_Procedure

    //> If you have a 2 level scan (scanning orders, and order lines for each order) you can save execution time by creating
    //> the sub-query only once and then call ReUse to reinitialise it.
    //>
    //> This is how you might go about it without the ReUse method:
    //>
    //> <code>
    //>      Open Order
    //>      Open OrderLin
    //>      tTableQuery stOrderQuery stOrderlineQuery
    //>
    //>      Get NewQuery of oTQ Order.file_number to stOrderQuery
    //>
    //>      While (FindRecord(oTQ,&stOrderQuery))
    //>          Get NewQuery of oTQ OrderLin.file_number to stOrderlineQuery // New query for each order
    //>          Send AddFilterRelate of oTQ (&stOrderlineQuery) Order.file_number
    //>          While (FindRecord(oTQ,&stOrderlineQuery))
    //>          Loop
    //>      Loop
    //> </code>
    //>
    //> With the ReUse method you can skip the repeated "compilation" of the inner query:
    //>
    //> <code>
    //>      Open Order
    //>      Open OrderLin
    //>      tTableQuery stOrderQuery stOrderlineQuery
    //>      Get NewQuery of oTQ Order.file_number to stOrderQuery
    //>      Get NewQuery of oTQ OrderLin.file_number to stOrderlineQuery
    //>      Send AddFilterRelate of oTQ (&stOrderlineQuery) Order.file_number
    //>
    //>      While (FindRecord(oTQ,&stOrderQuery))
    //>          Send ReUse of oTQ (&stOrderlineQuery)
    //>          While (FindRecord(oTQ,&stOrderlineQuery))
    //>          Loop
    //>      Loop
    //> </code>
    //>
    Procedure ReUse tTableQuery ByRef stQ
        Move False to stQ._stControlBlock.bInitialized
    End_Procedure

    //> The scanning algorithm may transparantly to the FindRecord loop decide
    //> to find all the rows in advance (if for example the desired output order
    //> is incompatible with the optimum search order). But if you call ForcePrefind
    //> you can force the algorithm to pre-find the rows regardless of whether it
    //> is necessary (or not?).

    //> This is relevant if editing indexed columns of the rows found during the
    //> FindRecord loop.
    //
    //> ForcePrefetch has no relevance (but does no harm) when run on a SQL table because the
    //> algorithm in this case generates an SQL statement via the driver. In this
    //> mode way the rows are "pre-found" anyway.

    Procedure ForcePrefetch tTableQuery ByRef stQ // Records will be prefetched.
        Move True to stQ.bForcePrefetch
    End_Procedure

    //> Even if we are querying an SQL table we may have reasons to force TQ to use
    //> the record oriented driver interface. This call does that:
    //>
    //> <code>
    //>     Send ForcePrefetch of oTQ (&stQ)
    //> </code>
    //>
    //> If in addition we also want to specify the cache parameters used by the
    //> driver we can also specify prefetch count and cache timeout (for the
    //> duration of the query:
    //>
    //> <code>
    //>     Send ForcePrefetch of oTQ (&stQ) 1000 2000
    //> </code>
    //>
    //> This sets the prefetch cache to 1000 records and cache timeout to 2 seconds
    //> and this will most likely give a boost compared to the default values which
    //> are 10 records / 10ms.

    Procedure ForceNoESQL tTableQuery ByRef stQ Integer iPrefetchSize Integer iCacheTimeoutMS // ESQL will not be applied
        Move True to stQ.bNoESQL
        If  (num_arguments>1) Begin
            Move True to stQ._stControlBlock.stSQLCacheControl.bUseSettings
            Move iPrefetchSize to stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordCount
            If (num_arguments>2) Begin
                Move iCacheTimeoutMS to stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordTimeout
            End
            Else Begin
                Move 0 to stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordTimeout
            End
        End
        Else Begin
            Move False to stQ._stControlBlock.stSQLCacheControl.bUseSettings
        End
    End_Procedure

    //> Don't evaluate, just use iIndex I tell you. Ignored by ESQL
    Procedure ForceIndex tTableQuery ByRef stQ Integer iIndex
        Move iIndex to stQ.iForceIndex
    End_Procedure

    //> Limit number of rows in the result set.
    Procedure SetLimit tTableQuery ByRef stQ Integer iLimit
        Move iLimit to stQ.iLimit
    End_Procedure

//    Procedure SetExpectedNumberOfRecords tTableQuery ByRef stQ Integer iResultSetSize // Just a thought
//    End_Procedure

    //> Use this table name when generating ESQL rather than the default one. Because I tell you to!
    Procedure ForceSQLTableName tTableQuery ByRef stQ String sSqlTableName
        Move sSqlTableName to stQ.sForceSQLTableName
    End_Procedure

    //> DANGER! Completely overtakes the scene. Make sure to "select" the columns expected by TQ
    Procedure ForceSQLStatement tTableQuery ByRef stQ String sSQLStatement
        Move sSQLStatement to stQ.sForceSQLStatement
    End_Procedure

    //> Call this procedure to ensure that all recordbuffers are left exactly the way they were found, when the query is complete.
    Procedure RestoreRecordBuffersOnQueryCompletion tTableQuery ByRef stQ Boolean bState
        Move bState to stQ.bRestoreRecordBuffersOnQueryCompletion
    End_Procedure
    
    Procedure SetBreakLevelTest tTableQuery ByRef stQ Boolean bState
        Move bState to stQ.bBreakLevelTest
    End_Procedure

    //> Use LogTag to distinguish between different FindRecord loops in the log. Or
    //> between different situations in different runs of the same FindLoop. When this is set, TQ
    //> will create a record in an un-listed log table by the name of (LogTableName(oTQ,stQ))
    Procedure SetLogTag tTableQuery ByRef stQ String sTag
        Move sTag to stQ._stControlBlock.sLogTag
    End_Procedure

    //> Call BreakScan to terminate the FindRecord loop on next iteration. Note that when (explicitly or implicitly) we have set
    //> the bForcePrefetch attribute, this will not be effective until we enter the actual find-loop. Which in that case will be
    //> after all the rows have been found.
    Procedure BreakScan tTableQuery ByRef stQ
        Move True to stQ._stControlBlock.bBreakScan
    End_Procedure

    //> After query execution this will return an string: "So many selected rows in so many finds"
    Function StatisticsString tTableQuery stQ Returns String
        Integer iFound iSelect
        Move stQ._stControlBlock.iFindCount to iFound
        Move stQ._stControlBlock.iSelectCount to iSelect
        Function_Return (String(iSelect)+" selected rows (in "+String(iFound)+" finds)")
    End_Function

    //> Returns the number of milliseconds it takes to make an "empty" round-trip to the SQL server. It makes at least 4 server calls.
    Function ZeroSelectTime Integer iTable Returns Number
        tSystemTimeMS stStart stStop
        tTableQuery stQ
        Boolean bFound

        Get NewQuery iTable to stQ
        Send ForceSQLStatement (&stQ) "select 1"
        Repeat
            Get FindRecord (&stQ) to bFound
        Until (not(bFound))

        Send ReUse (&stQ)
        Get SystemTimeMilliSeconds of oDateFunctions to stStart // We time the second loop (in case the first loop had to set up a connection)
        Repeat
            Get FindRecord (&stQ) to bFound
        Until (not(bFound))

        Get SystemTimeMilliSeconds of oDateFunctions to stStop
        Function_Return (SystemTimeMilliSecondsElapsed(oDateFunctions,stStart, stStop))
    End_Function

        //> Returns the table name of iTable as used (in SQL staments) in the stQ context.
        Function TableName tTableQuery stQ Integer iTable Returns String
            Integer iRelateItem
            String sValue
            If (iTable=stQ.iTable) Begin
                Move stQ.sForceSQLTableName to sValue
            End
            Else Begin
                Get _FindTableRelation stQ iTable to iRelateItem
                If (iRelateItem>=0) Begin
                    Move stQ.aTableRelations[iRelateItem].sForceSQLTableName to sValue
                End
            End
            If (sValue="") Begin
                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
            End
            If (sValue="") Begin
                Send OnError 701 ("Table name could not be found for table "+String(iTable))
            End

            Function_Return sValue
        End_Function

        //> Returns column name of iTable.iColumn as used (in SQL staments) in the stQ context.
        Function ColumnName tTableQuery stQ Integer iTable Integer iColumn Boolean bIncludeTableName Returns String
            String sColumnName sTableName
            Get_Attribute DF_FIELD_NAME of iTable iColumn to sColumnName
            If (sColumnName<>"") Begin
                If (bIncludeTableName) Begin
                    Get TableName stQ iTable to sTableName
                    Function_Return (sTableName+"."+sColumnName)
                End
                Else Begin
                    Function_Return sColumnName
                End
            End
            Function_Return ""
        End_Function

        Function ComperatorID2String Integer iComp Returns String
            If (iComp=tqLT) Begin
                Function_Return "<"
            End
            If (iComp=tqLE) Begin
                Function_Return "<="
            End
            If (iComp=tqEQ) Begin
                Function_Return "="
            End
            If (iComp=tqGE) Begin
                Function_Return ">="
            End
            If (iComp=tqGT) Begin
                Function_Return ">"
            End
            If (iComp=tqNE) Begin
                Function_Return "<>"
            End
//            If (iComp=tqIN) Function_Return "in"
//            If (iComp=tqCONTAINS) Function_Return "contains"
            If (iComp=tqMATCH) Begin
                Function_Return "match"
            End
            If (iComp=tqUCMATCH) Begin
                Function_Return "ucmatch"
            End
            Function_Return "error"
        End_Function

        Function ComperatorID2ComperatorString Integer iComp Returns String
            If (iComp=tqLT) Begin
                Function_Return "tqLT"
            End
            If (iComp=tqLE) Begin
                Function_Return "tqLE"
            End
            If (iComp=tqEQ) Begin
                Function_Return "tqEQ"
            End
            If (iComp=tqGE) Begin
                Function_Return "tqGE"
            End
            If (iComp=tqGT) Begin
                Function_Return "tqGT"
            End
            If (iComp=tqNE) Begin
                Function_Return "tqNE"
            End
//            If (iComp=tqIN) Function_Return "tqIN"
//            If (iComp=tqCONTAINS) Function_Return "tqCONTAINS"
            If (iComp=tqMATCH) Begin
                Function_Return "tqMATCH"
            End
            If (iComp=tqUCMATCH) Begin
                Function_Return "tqUCMATCH"
            End
        End_Function

        Function ComperatorString2ID String sComp Returns Integer
            Integer iMax iItem
            Move (_tqComparisonMax-1) to iMax
            Move (Lowercase(sComp)) to sComp
            For iItem from 0 to iMax
                If (sComp=Lowercase(ComperatorID2String(Self,iItem))) Begin
                    Function_Return iItem
                End
            Loop
            Function_Return -1 // not found
        End_Function

    //> Send a number of these to specify the ordering of the result set. That's it.
    //> <code>
    //> Send AddOrderBy of oTQ (&stQ) file_field <TableName.ColumnName> <bDescending> <bCaseInsensitive>
    //> </code>
    Procedure AddOrderBy tTableQuery ByRef stQ Integer iTable Integer iColumn Boolean bDescending Integer bUppercase
        Integer iCount iRelateItem
        Move (SizeOfArray(stQ.aOrdering)) to iCount
        Move iTable to stQ.aOrdering[iCount].stValueSource.iTable
        Move iColumn to stQ.aOrdering[iCount].stValueSource.iColumn
        Get _ColumnType iTable iColumn to stQ.aOrdering[iCount].stValueSource.iType
        If (num_arguments>=4) Begin
            Move bDescending to stQ.aOrdering[iCount].bDescending
        End
        Else Begin
            Move False to stQ.aOrdering[iCount].bDescending
        End
        If (num_arguments>=5) Begin
            Move bUppercase to stQ.aOrdering[iCount].bUppercase
        End
        Else Begin // if not passed to the procedure we'll assume "don't care"
            Move -1 to stQ.aOrdering[iCount].bUppercase
        End
        If (iTable<>stQ.iTable) Begin
            // We will also check if this parent table is accessible via the known table relations:
            Get _FindTableRelation stQ iTable to iRelateItem
            If (iRelateItem=-1) Begin
                Send OnError 702 ("Unknown table relation to table "+String(iTable))
            End
            Else Begin
                // We're ordering by a parent table column which makes us have to prefetch the result. 
                //
                // Unless the ordering is cancelled out because the parent table is actually fixed by 
                // the filters. A check for this has however not been implemented. It would involve
                // asking whether the parent table itself is fixed by filtering and if not, if the
                // relating child record is fixed, and if not the grandparent asf. until we hit
                // the main table of the query. I deem that too expensive and it has not been implemented.
                Move True to stQ.bForcePrefetch
            End
        End
    End_Procedure

    //> 
    Procedure AddOrderByExpression tTableQuery ByRef stQ ;
                                   String sExpression ;
                                   Integer iValueType ; //> tqString, tqNumber, tqDate ...
                                   Integer iLength ;
                                   Integer iDecimals ;
                                   Boolean bDescending 
        Integer hoExprParser
        Integer[] aLegalTables // For expressions
        tXPGrammar stGrammar
        tXPError stError
        tTQOrderBySegment stSegment

        Get phoExprParser to hoExprParser
        
        Get LegalExpressionTables stQ to aLegalTables
        Set paAllowedTables of hoExprParser to aLegalTables
        
        Get NewGrammar of hoExprParser to stGrammar
        Get TokenizeString of hoExprParser stGrammar sExpression (&stError) to stSegment.stValueSource.aSymbols // Parse orderby expression
        Move sExpression to stSegment.stValueSource.sConstant
        
        If (stError.sErrorText="") Begin
            Get ReversePolishNotation of hoExprParser stGrammar stSegment.stValueSource.aSymbols (&stError) to stSegment.stValueSource.aSymbols
            If (stError.sErrorText="") Begin
                Move bDescending to stSegment.bDescending
                Move False to stSegment.bUppercase
                Move iValueType to stSegment.stValueSource.iType
                Move iLength to stSegment.stValueSource.iLen
                Move iDecimals to stSegment.stValueSource.iDecimals
                Move stSegment to stQ.aOrdering[SizeOfArray(stQ.aOrdering)]
            End
            Else Begin
                Send OnError 750 stError.sErrorText
            End
        End
        Else Begin
            Send OnError 749 stError.sErrorText
        End
        Set paAllowedTables of hoExprParser to (ResizeArray(aLegalTables,0))
    End_Procedure
    
    //> Delete all ordering information from the stQ variable
    Procedure ResetOrdering tTableQuery ByRef stQ
        // Check that the query is not already executing
        If (stQ._stControlBlock.bInitialized) Begin
            Send OnError 740 "ResetOrdering called while query is executing"
        End
        Else Begin
            Move (ResizeArray(stQ.aOrdering,0)) to stQ.aOrdering
        End
    End_Procedure
    
    Function _FindOrderBySegment tTableQuery stQ Integer iTable Integer iColumn Returns Integer
        Integer iItem iItemMax
        Move (SizeOfArray(stQ.aOrdering)-1) to iItemMax
        For iItem from 0 to iItemMax
            If (iTable=stQ.aOrdering[iItem].stValueSource.iTable and iColumn=stQ.aOrdering[iItem].stValueSource.iColumn) Begin
                Function_Return iItem
            End
        Loop
        Function_Return -1 // Not found
    End_Function

    //> Shorthand for sending the AddOrdering a number of times to match the factual search order of a particular index. It's hard to explain why you'd do it.
    Procedure SetOrderByToIndex tTableQuery ByRef stQ Integer iIndex
        tOCIndex stIndex
        Integer iSegment iSegments
        Get IndexDefinition of oOverlapColumnFunctions stQ.iTable iIndex to stIndex
        Move (SizeOfArray(stIndex.aSegments)-1) to iSegments
        For iSegment from 0 to iSegments
            Send AddOrderBy (&stQ) stQ.iTable stIndex.aSegments[iSegment].iColumn stIndex.aSegments[iSegment].bDescending stIndex.aSegments[iSegment].bUppercase
        Loop
    End_Procedure
    
    //> Utility function to convert a DF column type to a TQ column type.
    Function DFTypeToTQType Integer iDFType Returns Integer
        If (iDFType=DF_ASCII) Begin
            Function_Return tqSTRING
        End
        If (iDFType=DF_OVERLAP) Begin
            Function_Return tqSTRING
        End
        If (iDFType=DF_BCD) Begin
            Function_Return tqNUMBER
        End
        If (iDFType=DF_DATE) Begin
            Function_Return tqDATE
        End
        If (iDFType=DF_DATETIME) Begin
            Function_Return tqDATETIME
        End
        If (iDFType=DF_TEXT) Begin
            Function_Return tqTEXT
        End
        Function_Return -1
    End_Function
    
    Function XPTypeToTQType Integer iXPType Returns Integer
        If (iXPType=XP_String) Begin
            Function_Return tqSTRING
        End
        If (iXPType=XP_Numeric) Begin
            Function_Return tqNUMBER
        End
        If (iXPType=XP_Integer) Begin
            Function_Return tqNUMBER
        End
        If (iXPType=XP_Date) Begin
            Function_Return tqDATE
        End
        If (iXPType=XP_Boolean) Begin
            Function_Return tqNUMBER
        End
        Function_Return -1
    End_Function
    
    Function TQTypeToXPType Integer iTQType Returns Integer
        If (iTQType=tqSTRING) Begin
            Function_Return XP_String
        End
        If (iTQType=tqNUMBER) Begin
            Function_Return XP_Numeric
        End
        If (iTQType=tqTEXT) Begin
            Function_Return XP_String
        End
        If (iTQType=tqDATE) Begin 
            Function_Return XP_Date
        End
// Should fail on tqDATETIMEs
//        If (iTQType=tqDATETIME) ;
//                Function_Return XP_Date
        Function_Return -1
    End_Function
    
    Function TQTypeToString Integer iTQType Returns String
        If (iTQType=tqSTRING) Begin
            Function_Return "tqSTRING"
        End
        If (iTQType=tqNUMBER) Begin
            Function_Return "tqNUMBER"
        End
        If (iTQType=tqTEXT) Begin
            Function_Return "tqTEXT"
        End
        If (iTQType=tqDATE) Begin
            Function_Return "tqDATE"
        End
        If (iTQType=tqDATETIME) Begin
            Function_Return "tqDATETIME"
        End
        Function_Return ("Not a TQ type")
    End_Function

        Function _ColumnType Integer iTable Integer iColumn Returns Integer
            Integer iDFType
            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iDFType
            Function_Return (DFTypeToTQType(Self,iDFType))
        End_Function

    Procedure AddFilter tTableQuery ByRef stQ Integer iTable Integer iColumn Integer iComp String sConstant
        Integer iRelateItem
        tTQFilterSegment stSegment

        Move iTable to stSegment.stLeftValue.iTable
        Move iColumn to stSegment.stLeftValue.iColumn
        Get _ColumnType iTable iColumn to stSegment.stLeftValue.iType
        Move iComp to stSegment.iComp
        Move sConstant to stSegment.stRightValue.sConstant
        Get _ColumnType iTable iColumn to stSegment.stRightValue.iType

        If (iTable<>stQ.iTable) Begin
            // Check if this parent table is accessible via the known table relations:
            Get _FindTableRelation stQ iTable to iRelateItem
            If (iRelateItem=-1) Begin
                Send OnError 703 ("Unknown table relation to table "+String(iTable))
            End
        End
        Move stSegment to stQ.aFilters[SizeOfArray(stQ.aFilters)]
    End_Procedure
    
    Procedure AddFilterExpression tTableQuery ByRef stQ String sExpression 
        Integer hoExprParser
        Integer[] aLegalTables // For expressions
        tXPGrammar stGrammar
        tXPError stError
        tTQFilterSegment stFilter
        
        Get phoExprParser to hoExprParser
        
        Get LegalExpressionTables stQ to aLegalTables
        Set paAllowedTables of hoExprParser to aLegalTables
        
        // In the event of an expression filter we use the right hand side of the filter only.
        
        Get NewGrammar of hoExprParser to stGrammar
        Get TokenizeString of hoExprParser stGrammar sExpression (&stError) to stFilter.stRightValue.aSymbols // Parse filter expression
        Move sExpression to stFilter.stRightValue.sConstant

        If (stError.sErrorText="") Begin
            Get ReversePolishNotation of hoExprParser stGrammar stFilter.stRightValue.aSymbols (&stError) to stFilter.stRightValue.aSymbols
            If (stError.sErrorText="") Begin
                Move tqNUMBER to stFilter.stRightValue.iType
                Move 1 to stFilter.stRightValue.iLen
                Move 0 to stFilter.stRightValue.iDecimals
                Move stFilter to stQ.aFilters[SizeOfArray(stQ.aFilters)]
            End
            Else Begin
                Send OnError 748 -1 stError.sErrorText
            End
        End
        Else begin
            Send OnError 747 -1 stError.sErrorText
        End
        Set paAllowedTables of hoExprParser to (ResizeArray(aLegalTables,0))
    End_Procedure

    Procedure AddFilterInList tTableQuery ByRef stQ Integer iTable Integer iColumn String[] aList
        Integer iFilterIndex iRelateItem
        tTQFilterSegment stSegment

        Move iTable to stSegment.stLeftValue.iTable
        Move iColumn to stSegment.stLeftValue.iColumn
        Get _ColumnType iTable iColumn to stSegment.stLeftValue.iType
        Move tqEQ to stSegment.iComp
        Move aList to stSegment.stRightValue.aOrList
        Move 0 to stSegment.stRightValue._iOrListPointer
        Get _ColumnType iTable iColumn to stSegment.stRightValue.iType

        If (iTable<>stQ.iTable) Begin
            // Check if this parent table is accessible via the known table relations:
            Get _FindTableRelation stQ iTable to iRelateItem
            If (iRelateItem=-1) Begin
                Send OnError 704 ("Unknown table relation to table "+String(iTable))
            End
        End
        
        Move (SizeOfArray(stQ.aFilters)) to iFilterIndex
        Move stSegment to stQ.aFilters[iFilterIndex]
    End_Procedure

    Procedure AddFilterNotInList tTableQuery ByRef stQ Integer iTable Integer iColumn String[] aList
        Integer iFilterIndex
        Send AddFilterInList (&stQ) iTable iColumn aList
        Move (SizeOfArray(stQ.aFilters)-1) to iFilterIndex
        Move tqNE to stQ.aFilters[iFilterIndex].iComp
    End_Procedure
    
    Procedure AddFilterTableColumn tTableQuery ByRef stQ Integer iTable Integer iColumn Integer iComp Integer iFilterTable Integer iFilterColumn
        Integer iFilterIndex iRelateItem
        tTQFilterSegment stSegment

        Move iTable to stSegment.stLeftValue.iTable
        Move iColumn to stSegment.stLeftValue.iColumn
        Get _ColumnType iTable iColumn to stSegment.stLeftValue.iType
        Move iComp to stSegment.iComp
        Move iFilterTable to stSegment.stRightValue.iTable
        Move iFilterColumn to stSegment.stRightValue.iColumn
        Get _ColumnType iFilterTable iFilterColumn to stSegment.stRightValue.iType

        If (stSegment.stLeftValue.iTable<>stQ.iTable) Begin
            // Check if left hand table is accessible via the known table relations:
            Get _FindTableRelation stQ stSegment.stLeftValue.iTable to iRelateItem
            If (iRelateItem=-1) Begin
                Send OnError 705 ("Unknown table relation to table "+String(stSegment.stLeftValue.iTable))
            End
        End

        Move (SizeOfArray(stQ.aFilters)) to iFilterIndex
        Move stSegment to stQ.aFilters[iFilterIndex]
    End_Procedure
    
//    Procedure SetLastFilterCaseInsensitive tTableQuery ByRef stQ 
//        Move True to stQ.aFilters[SizeOfArray(stQ.aFilters)-1].bUppercaseFilter
//    End_Procedure
    
        Procedure _AddConstrainRelateSegments tTableQuery ByRef stQ Integer iTable Integer[] aColumns Integer iRelTable Integer[] aRelColumns
            Integer iColumns iItem
            Move (SizeOfArray(aColumns)-1) to iColumns
            If ((iColumns+1)<>SizeOfArray(aRelColumns)) Begin
                Send OnError 706 "Number of segments do not match in AddFilterRelate method"
            End
            For iItem from 0 to iColumns
                Send AddFilterTableColumn (&stQ) iTable aColumns[iItem] tqEQ iRelTable aRelColumns[iItem]
            Loop
        End_Procedure

    Procedure AddFilterRelate tTableQuery ByRef stQ Integer iParentTable
        Integer iTable iColumn iColumns iRelTable iRelColumn
        Boolean bAnyColumnsAtAll
        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
        Move stQ.iTable to iTable
        Move False to bAnyColumnsAtAll
        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
        For iColumn from 1 to iColumns
            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
            If (iRelTable=iParentTable) Begin
                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
                Send _AddConstrainRelateSegments (&stQ) stQ.iTable (TranslateOverlap(oOverlapColumnFunctions,iTable,iColumn)) iRelTable (TranslateOverlap(oOverlapColumnFunctions,iRelTable,iRelColumn))
                Move True to bAnyColumnsAtAll
            End
        Loop
        If (bAnyColumnsAtAll) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
            // Tell the relationship handler that it should not worry about iParentTable. It is automatically and constantly related.
            Send AddTableRelationFixedRecord (&stQ) iParentTable 
        End
        Else Begin
            Send OnError 707 "Main query table does not relate to the parent table passed"
        End
    End_Procedure

    //> AddFilterRelateFixedRecord is equivalent to AddFilterRelate but it defines the
    //> filter based on constant filters rather than dynamic "table column filters".
    Procedure AddFilterRelateFixedRecord tTableQuery ByRef stQ Integer iParentTable
        Integer iTable iColumn iColumns iRelTable iRelColumn iIndex iMax
        Integer[] aColumns aRelColumns
        String sValue
        Boolean bAnythingAtAll
        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
        Move stQ.iTable to iTable
        Move False to bAnythingAtAll
        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
        For iColumn from 1 to iColumns
            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
            If (iRelTable=iParentTable) Begin
                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
                Get TranslateOverlap of oOverlapColumnFunctions iTable iColumn to aColumns
                Get TranslateOverlap of oOverlapColumnFunctions iRelTable iRelColumn to aRelColumns
                Move (SizeOfArray(aColumns)-1) to iMax
                If ((iMax+1)=SizeOfArray(aRelColumns)) Begin
//                    Get_Field_Value iRelColumn aRelColumns[iIndex] to sValue 
                    Get_Field_Value iRelTable aRelColumns[iIndex] to sValue
                    Send AddFilter (&stQ) iTable aColumns[iIndex] tqEQ sValue
                    Move True to bAnythingAtAll
                End
                Else Begin
                    Send OnError 745 "Number of segments do not match in AddFilterRelateAsConstant method"
                End
            End
        Loop
        If (not(bAnythingAtAll)) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
            Send OnError 746 "Main query table does not relate to the parent table passed"
        End
    End_Procedure

        Function _ValidateQuery tTableQuery stQ Returns Boolean
            // Check that no more than 1 constraints is put on each column (allow for interval checking though)
            Integer iConstrainMax iConstrainIndex iComp 
            Integer iNewLoad iCurrentLoad iColumn
            Integer iTable
            Integer[][] aaConstrainLoads
            Move (SizeOfArray(stQ.aFilters)-1) to iConstrainMax
            For iConstrainIndex from 0 to iConstrainMax

                Move stQ.aFilters[iConstrainIndex].stLeftValue.iTable to iTable

                If (iTable>=SizeOfArray(aaConstrainLoads)) Begin
                    Move 0 to aaConstrainLoads[iTable][0]
                End

                // Check that no more than 1 constraints is put on each column (allow for interval checking though)
                Move stQ.aFilters[iConstrainIndex].iComp to iComp
                If (iComp=tqGT or iComp=tqGE) Begin
                    Move 1 to iNewLoad      // 01
                End
                Else If (iComp=tqLT or iComp=tqLE) Begin
                    Move 2 to iNewLoad // 10
                End
                Else Begin
                    Move 3 to iNewLoad                               // 11
                End

                Move stQ.aFilters[iConstrainIndex].stLeftValue.iColumn to iColumn
                
                If (iColumn>=SizeOfArray(aaConstrainLoads[iTable])) Begin
                    Move 0 to iCurrentLoad
                End
                Else Begin
                    Move aaConstrainLoads[iTable][iColumn] to iCurrentLoad
                End
                If (iNewLoad iand iCurrentLoad) Begin
                    Send OnError 739 (Replace("#","Illegal filter. Column # is over-constrained",ColumnName(Self,stQ,iTable,iColumn,True)))
                    Function_Return False
                End
                Move (iCurrentLoad+iNewLoad) to aaConstrainLoads[iTable][iColumn]

                // ToDo: (maybe) Check that tables used for AddFilterRelate are not used as relate tables also.
            Loop
            Function_Return True
        End_Function

        Function _IsTableFixed tTableQuery stQ Integer iTable Returns Boolean
            Integer iRelateItem
            If (iTable=stQ.iTable) Begin
                Function_Return False // If it's the main table of the query it is definitely not fixed.
            End
            Get _FindTableRelation stQ iTable to iRelateItem
            If (iRelateItem<>-1) Begin
                Function_Return stQ.aTableRelations[iRelateItem].bFixed
            End
            Send OnError 735 ("Table not related: "+String(iTable))
        End_Function

        Function _ColumnRatings tTableQuery stQ Returns Number[]
            // Calculate an array of columns that can be used for jump-in /jump-out.
            // If a column has a jump-in value or a jump-out value it is rated (apr) 0.5.
            // If a column has both it is rated 2.0.
            Integer iColumn
            Integer iIndex iIndices
            Integer iSegment iSegments
            Integer iConstraint iConstraints
            Integer iTable iComp

            Number[] aColumnRatings
            tOCTable stTable

            Move stQ.iTable to iTable

            Get TableDefinition of oOverlapColumnFunctions iTable to stTable

            Move (SizeOfArray(stTable.aIndices)-1) to iIndices
            Move (SizeOfArray(stQ.aFilters)-1) to iConstraints
            Move (ResizeArray(aColumnRatings,SizeOfArray(stTable.aColumns))) to aColumnRatings

            For iIndex from 1 to iIndices
                Move (SizeOfArray(stTable.aIndices[iIndex].aSegments)-1) to iSegments

                For iSegment from 0 to iSegments
                    Move stTable.aIndices[iIndex].aSegments[iSegment].iColumn to iColumn

                    If (aColumnRatings[iColumn]=0) Begin // To avoid the same column getting added ratings because appearing in multiple indices

                        For iConstraint from 0 to iConstraints

                            // Only evaluate filters that:
                            //  1. (left side) filters on a column in the query main table. Note that this also excludes expressions, because they have no left-hand-side
                            //  2. (right side) does not filter on a column from a table that changes on each new main table record

                            If ( stQ.aFilters[iConstraint].stLeftValue.iTable=iTable and ;
                                    ( stQ.aFilters[iConstraint].stRightValue.iTable=0 or ;
                                      _IsTableFixed(Self,stQ,stQ.aFilters[iConstraint].stRightValue.iTable) )) Begin

                                Move stQ.aFilters[iConstraint].iComp to iComp
                                If (iColumn=stQ.aFilters[iConstraint].stLeftValue.iColumn) Begin

                                    If (iComp=tqEQ) Begin
                                        Move 2 to aColumnRatings[iColumn]
                                    End
                                    Else If (iComp=tqGE or iComp=tqGT) Begin
                                        Move (aColumnRatings[iColumn]+0.49) to aColumnRatings[iColumn]
                                    End
                                    Else If (iComp=tqLT or iComp=tqLE) Begin
                                        Move (aColumnRatings[iColumn]+0.51) to aColumnRatings[iColumn]
                                    End
                                    // Note: Using the values 0.49 and 0.51 is a trick to allow the consumer
                                    //       of these data to determine whether the constraining operator
                                    //       was Lx or Gx (or both). It means nothing to the final ranking
                                    //       of the indices. They are both weighed by 0.5.
                                End
                            End
                        Loop
                    End
                Loop
            Loop

            Function_Return aColumnRatings
        End_Function

            // If this returns true column iColumn is constrained to a fixed value. (If it is, the
            // column may be discarded if appearing as a most-significant index segment)
            Function _ColumnFixedByEqConstraint tTableQuery stQ Integer iColumn Returns Boolean
                Integer iFilterIndex iFilterMax
                tTQFilterSegment stConstraint

                Move (SizeOfArray(stQ.aFilters)-1) to iFilterMax
                For iFilterIndex from 0 to iFilterMax
                    Move stQ.aFilters[iFilterIndex] to stConstraint
                    If (stConstraint.iComp=tqEQ and ;
                        stConstraint.stLeftValue.iTable=stQ.iTable and ;
                        stConstraint.stLeftValue.iColumn=iColumn and ;
                        SizeOfArray(stConstraint.stRightValue.aOrList)<2) Begin
                        Function_Return True
                    End
                Loop
                Function_Return False
            End_Function

            Function _IndexSegmentAgreement tTQOrderBySegment stOrderSegment Integer iTable tOCIndexSegment[] aIndexSegments Integer iIndexSegment Boolean bBackwards Boolean bEQ Returns Boolean
                If (iIndexSegment<SizeOfArray(aIndexSegments)) Begin //If there is no more segments in the index then obviously we cant be in agreement
                    If (stOrderSegment.stValueSource.iTable=iTable) Begin // If the required segment is of another table we're definately not in agreement
                        If (stOrderSegment.stValueSource.iColumn=aIndexSegments[iIndexSegment].iColumn) Begin
                            If (stOrderSegment.bUppercase=-1 or (stOrderSegment.bUppercase=1)=aIndexSegments[iIndexSegment].bUppercase) Begin // -1=don't care
                                If (bEQ) Begin // It doesn't matter if they don't match if we are under an EQ constraint
                                    Function_Return True // So we just say: fine!
                                End
                                // If we are not under an EQ constraint we have to consider the direction:
                                If (bBackwards) Begin
                                    If ((Integer(stOrderSegment.bDescending)+Integer(aIndexSegments[iIndexSegment].bDescending))=1) Begin // xor = if they are opposite
                                        Function_Return True
                                    End
                                End
                                Else Begin
                                    If (stOrderSegment.bDescending=aIndexSegments[iIndexSegment].bDescending) Begin
                                        Function_Return True
                                    End
                                End
                            End
                        End
                    End
                End
                Function_Return False
            End_Function
            
            // The index is trimmed in the sense that most-significant segments of the index are removed
            // if they are bounded by an eq-constraint.
            Function _TrimIndexSegments tTableQuery stQ tOCIndexSegment[] aIndexSegments Returns tOCIndexSegment[]
                Integer iSegments iSkipSegments
                tOCIndexSegment[] aRemainingSegments
                Move 0 to iSkipSegments
                Move (SizeOfArray(aIndexSegments)-1) to iSegments
                While (iSkipSegments<=iSegments and _ColumnFixedByEqConstraint(Self,stQ,aIndexSegments[iSkipSegments].iColumn))
                    Increment iSkipSegments
                Loop
                If (SizeOfArray(aIndexSegments)>0) Begin
                    Move (CopyArray(aIndexSegments,iSkipSegments,iSegments)) to aRemainingSegments
                End
                Function_Return aRemainingSegments
            End_Function
            
            Function _TrimOrderBySegments tTableQuery stQ tTQOrderBySegment[] aOrderingBySegments Returns tTQOrderBySegment[]
                Integer iTable
                Integer iSegments iSkipSegments
                tTQOrderBySegment[] aRemainingSegments

                Move stQ.iTable to iTable
                Move 0 to iSkipSegments
                Move (SizeOfArray(aOrderingBySegments)-1) to iSegments
                If (iSegments>=0) Begin
                    While (iSkipSegments<=iSegments and aOrderingBySegments[iSkipSegments].stValueSource.iTable=iTable and _ColumnFixedByEqConstraint(Self,stQ,aOrderingBySegments[iSkipSegments].stValueSource.iColumn))
                        Increment iSkipSegments
                    Loop
                    Move (CopyArray(aOrderingBySegments,iSkipSegments,iSegments)) to aRemainingSegments
                End
                Function_Return aRemainingSegments
            End_Function
            
        Function _IndexAgreement tTableQuery stQ Integer iIndex Boolean bFinalDecision Returns Boolean
            // Is the index in agreement with the specified output order?
            //
            // For each segment in the desired output order it must be the case that it is a
            // table column based segment and that either:
            //  
            //     1)   its value is fixed by a eq-constraint and all segments before it has been 
            //          satisfied the same way (if the column happens to be the same as the
            //          "next segment" in the index we're testing, then we must disregard that
            //          segment from then on).
            // or
            //     2)   it is satisfied by the "next segment" in the index we're testing
            //
            tOCIndex              stIndex
            tOCIndexSegment[]     aIndexSegments
            tTQOrderBySegment[]   aOrderingSegments
            _tTQValueSource       stValueSource

            Boolean bOrderSegmentOK bIndexSegmentMatch
            Boolean bBackwards bEq
            Integer iIndexSegment iIndexSegments
            Integer iOrderingSegment iOrderingSegments
            Integer iConstraint
            
            If (stQ._stCompiled.nENR=0) Begin // If index is fully specified all indices agree
                Function_Return True
            End

            If (bFinalDecision) Begin
                Move stQ._stCompiled.bBackwards to bBackwards
            End
            Else Begin
                If (iIndex>1000) Begin
                    Move (iIndex-1000) to iIndex
                    Move True to bBackwards
                End
                Else Begin
                    Move False to bBackwards
                End
            End
            
            Get IndexDefinition of oOverlapColumnFunctions stQ.iTable iIndex to stIndex
            
            Get _TrimIndexSegments stQ stIndex.aSegments to aIndexSegments
            Get _TrimOrderBySegments stQ stQ.aOrdering to aOrderingSegments

            Move (SizeOfArray(aIndexSegments)-1) to iIndexSegments
            Move (SizeOfArray(aOrderingSegments)-1) to iOrderingSegments
            
            Move 0 to iIndexSegment
            
            For iOrderingSegment from 0 to iOrderingSegments
                Move False to bOrderSegmentOK
                Move aOrderingSegments[iOrderingSegment].stValueSource to stValueSource
                If (iOrderingSegment<=iIndexSegments and stValueSource.iTable=stQ.iTable) Begin // If the order-segment is main-table-based
                    
                    Get _FindConstraintEQ stQ.aFilters stQ.iTable stValueSource.iColumn False to iConstraint
                    Move (iConstraint<>-1) to bEq
                    
                    Get _IndexSegmentAgreement aOrderingSegments[iOrderingSegment] stQ.iTable aIndexSegments iIndexSegment bBackwards bEq to bIndexSegmentMatch
                    
                    If (bIndexSegmentMatch) Begin
                        Move True to bOrderSegmentOK
                        Increment iIndexSegment
                    End
                    Else Begin
                        // If the segment is constrained by an EQ we are still in agreement
                        If (_ColumnFixedByEqConstraint(Self,stQ,stValueSource.iColumn)) Begin
                            Move True to bOrderSegmentOK
                        End
                    End
                End

                If (not(bOrderSegmentOK)) Begin
                    Function_Return False
                End
            Loop
            Function_Return True
        End_Function

        Function _IndexExpectedNumberRows tTableQuery stQ Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis stIndexA Returns Number
            Boolean bAccept
            Integer iTable iColumn
            Integer iSegmentIndex iSegmentMax iPushIndex
            Number nExpectedNumberRows 
            tOCIndex stIndex
            Number nColumnRating
            
            If (iIndex>=1000) Begin
                Move (iIndex-1000) to iIndex
            End

            Move stQ.iTable to iTable
            Get_Attribute DF_FILE_RECORDS_USED of iTable to nExpectedNumberRows
            Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to stIndex
            Move (SizeOfArray(stIndex.aSegments)) to iSegmentMax

            Move True to bAccept
            Move 0 to iSegmentIndex
            
            While (bAccept and iSegmentIndex<iSegmentMax) // From l-to-r: get all consecutive EQ segments
                Move stIndex.aSegments[iSegmentIndex].iColumn to iColumn
                Move aColumnRatings[iColumn] to nColumnRating
                Move (nColumnRating=2) to bAccept
                If (bAccept) Begin
                    Move (nExpectedNumberRows*stIndexA.aSegmentReductions[iSegmentIndex]) to nExpectedNumberRows
                    Increment iSegmentIndex
                End
            Loop
            
            If (bAccept) Begin // Means that all segments have been provided eq constraints
                Function_Return 0 // The best possible result    
            End
            
            Move iSegmentIndex to iPushIndex
            Move True to bAccept
            
            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive GE/GT segments
                Move stIndex.aSegments[iSegmentIndex].iColumn to iColumn
                Move aColumnRatings[iColumn] to nColumnRating
                Move (nColumnRating>=1 or nColumnRating=0.49) to bAccept
                If (bAccept) Begin
                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
                    Increment iSegmentIndex
                End
            Loop

            Move iPushIndex to iSegmentIndex
            Move True to bAccept

            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive LE/LT segments
                Move stIndex.aSegments[iSegmentIndex].iColumn to iColumn
                Move aColumnRatings[iColumn] to nColumnRating
                Move (nColumnRating>=1 or nColumnRating=0.51) to bAccept
                If (bAccept) Begin
                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
                    Increment iSegmentIndex
                End
            Loop
            Function_Return nExpectedNumberRows
        End_Function

        Function _IndexRating tTableQuery stQ Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis stIndexA Returns _tTQIndexRating
            Integer iTable
            _tTQIndexRating stRating
            Move stQ.iTable to iTable
            Move iIndex to stRating.iIndex
            Get _IndexExpectedNumberRows stQ iIndex aColumnRatings stIndexA to stRating.nExpectedNumberRows
            If (stRating.nExpectedNumberRows=0) Begin
                Move True to stRating.bOutputAgree
            End
            Else Begin
                Get _IndexAgreement stQ iIndex False to stRating.bOutputAgree
            End
            If (iIndex>=1000) Begin // find lt by index iIndex-1000
                Move (iIndex-1000) to iIndex
                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to stRating.iKeyLevels
                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to stRating.iKeyLength
                Move (stRating.iKeyLength+1) to stRating.iKeyLength // Always prefer find gt to find lt when all else is equal
            End
            Else Begin
                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to stRating.iKeyLevels
                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to stRating.iKeyLength
            End

            Function_Return stRating
        End_Function

        Function _IndexRatings tTableQuery stQ Returns _tTQIndexRating[]
            // Create an array of defined indices on the table and for each index assign a rating
            // Sort the array of indices according to rating and pick the one with the highest one.
            Integer iItem iMax
            Integer iIndex
            Integer[] aIndices
            Number[] aColumnRatings
            tTQTableAnalysis strAnalysis
            _tTQIndexRating stRating
            _tTQIndexRating[] aIndexRatings

            Get TableAnalysis stQ.iTable to strAnalysis

            Get _ColumnRatings stQ to aColumnRatings

            Get TableIndices stQ.iTable to aIndices // All on-line indices

            Move (SizeOfArray(aIndices)-1) to iMax
            For iItem from 0 to iMax
                Move aIndices[iItem] to iIndex
                Get _IndexRating stQ iIndex aColumnRatings strAnalysis.aIndices[iIndex] to stRating
                Move stRating to aIndexRatings[SizeOfArray(aIndexRatings)]
                // Also check the reverse index:
                Get _IndexRating stQ (1000+iIndex) aColumnRatings strAnalysis.aIndices[iIndex] to stRating
                Move stRating to aIndexRatings[SizeOfArray(aIndexRatings)]
            Loop
            Function_Return aIndexRatings
        End_Function

//      Function _LowestIndexNumber Integer iTable Returns Integer
//          Integer iIndex iIndexMax iSegments
//
//          Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iIndexMax
//          Move 1 to iIndex
//          While (iIndex<=iIndexMax)
//              Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegments
//              If (iSegments<>0) Begin
//                  Function_Return iIndex
//              End
//              Increment iIndex
//          Loop
//
//          Function_Return 0 // None found
//      End_Function

        Function _CompareIndexRating _tTQIndexRating strRatingLeft _tTQIndexRating strRatingRight Returns Integer
            Number nFactorLeft nFactorRight
            Number nPrefetchAvoidanceFactor

            Get _pnPrefetchAvoidanceFactor to nPrefetchAvoidanceFactor
        
            // This means that we accept an index in agreement with the output order if it is more
            // than 10 times less efficient (assuming that nPrefetchAvoidanceFactor is 0.1 (which it is (by default)))
            Move (If(strRatingLeft.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorLeft
            Move (If(strRatingRight.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorRight
            
            Move (strRatingLeft.nExpectedNumberRows*nFactorLeft) to nFactorLeft
            Move (strRatingRight.nExpectedNumberRows*nFactorRight) to nFactorRight

            If (nFactorLeft > nFactorRight) Begin
                Function_Return (GT) // Right is best
            End
            If (nFactorLeft < nFactorRight) Begin
                Function_Return (LT) // Left is best
            End

            If (strRatingLeft.iKeyLevels>strRatingRight.iKeyLevels) Begin
                Function_Return (GT) // Right is best
            End
            If (strRatingLeft.iKeyLevels<strRatingRight.iKeyLevels) Begin
                Function_Return (LT) // Left is best
            End

            If (strRatingLeft.iKeyLength>strRatingRight.iKeyLength) Begin
                Function_Return (GT) // Right is best
            End
            If (strRatingLeft.iKeyLength<strRatingRight.iKeyLength) Begin
                Function_Return (LT) // Left is best
            End
                                                                                  
            Function_Return (EQ)
        End_Function

        Function _CalculateIndex tTableQuery ByRef stQ Returns _tTQIndexRating[] 
            Integer iIndex iIndexIndex
            Number nENR
            _tTQIndexRating[] aIndexRatings

            Get _IndexRatings stQ to aIndexRatings
            Move (SizeOfArray(aIndexRatings)-1) to iIndexIndex
            If (iIndexIndex>=0) Begin
                If (stQ.bForcePrefetch) Begin
                    // If prefetch is forced anyway, we will not consider prefetch an "extra" cost.
                    Set _pnPrefetchAvoidanceFactor to 1 
                End
                Else Begin
                    Set _pnPrefetchAvoidanceFactor to stQ._stControlBlock.nPrefetchAvoidanceFactor
                End
                Move (SortArray(aIndexRatings,Self,GET__CompareIndexRating)) to aIndexRatings
                Move aIndexRatings[0].iIndex to iIndex
                Move aIndexRatings[0].nExpectedNumberRows to nENR
            End
            Else Begin
                Move 0 to iIndex
                Move -1 to nENR // No idea
            End

            If (iIndex>=1000) Begin
                Move (iIndex-1000) to iIndex
                Move (not(stQ._stCompiled.bBackwards)) to stQ._stCompiled.bBackwards // Flip
            End
            
            Move iIndex to stQ._stCompiled.iIndex
            Move nENR to stQ._stCompiled.nENR
            
            Function_Return aIndexRatings
        End_Function
        
    Function IndexRatingText tTableQuery stQ _tTQIndexRating[] aIndexRatings Returns String
        Boolean bBackwards
        Integer iItem iMax iTable iIndex
        Number nRecCount nFactor
        String sValue sIndex sTemp

        Move stQ.iTable to iTable
        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecCount
        
        If (stQ.bForcePrefetch) Begin
            Move 1 to nFactor
        End
        Else Begin
            Move stQ._stControlBlock.nPrefetchAvoidanceFactor to nFactor
        End
        
        If (stQ.iForceIndex=-1) Begin
            Move "Index Ratings\n\nRatings are based on expected number of rows (ENR). If the use of an index implies prefetching and sorting data then ENR is multiplied by # (but not shown).\n\nIndex ratings, best to worst (there is # rows in table #):\n" to sValue
            Move (Replace("#",sValue,String(1.0/nFactor))) to sValue
            Move (Replace("#",sValue,NumberToString(oStringFunctions,nRecCount,0))) to sValue
            Move (Replace("#",sValue,TableName(Self,stQ,iTable))) to sValue
            Move (SizeOfArray(aIndexRatings)-1) to iMax
            For iItem from 0 to iMax
                Move "Index ##: ENR=#, #, Levels/length=#/#" to sIndex
                Move aIndexRatings[iItem].iIndex to iIndex
                If (iIndex>1000) Begin
                    Move (iIndex-1000) to iIndex
                    Move True to bBackwards
                End
                Else Begin
                    Move False to bBackwards
                End
                Move (Replace("#",sIndex,String(iIndex))) to sIndex
                If (bBackwards) Begin
                    Move (Replace("#",sIndex," (backwards)")) to sIndex
                End
                Else Begin
                    Move (Replace("#",sIndex,"")) to sIndex
                End
                Move (Replace("#",sIndex,String(aIndexRatings[iItem].nExpectedNumberRows))) to sIndex
                Move (If(aIndexRatings[iItem].bOutputAgree,"Ordering ok","Prefetch needed")) to sTemp
                Move (Replace("#",sIndex,sTemp)) to sIndex
                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLevels))) to sIndex
                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLength))) to sIndex
                Move (sValue+"\n"+sIndex) to sValue
            Loop
        End
        Else Begin
            Move "Indices have not been rated (index was forced)" to sValue
        End
        Function_Return sValue
    End_Function

    Procedure OnIndexCalculated tTableQuery stQ _tTQIndexRating[] aIndexRatings
    End_Procedure

                Function _FindConstraintEQ tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bOrListOnly Returns Integer
                    Integer iConstraint iConstraints
                    Move (SizeOfArray(aFilters)-1) to iConstraints
                    For iConstraint from 0 to iConstraints
                        If (iTable=aFilters[iConstraint].stLeftValue.iTable and ;
                            iColumn=aFilters[iConstraint].stLeftValue.iColumn and aFilters[iConstraint].iComp=tqEQ) Begin
                            If (not(bOrListOnly) or SizeOfArray(aFilters[iConstraint].stRightValue.aOrList)>0) Begin
                                Function_Return iConstraint
                            End
                        End
                    Loop
                    Function_Return -1
                End_Function

                Procedure _AppendConstraint tTQFilterSegment[] ByRef aConstraint tTQFilterSegment stConstraint Boolean bMakeItUppercased
                    Integer iIndex
                    Move (SizeOfArray(aConstraint)) to iIndex
                    If (bMakeItUppercased) Begin
                        Move True to stConstraint.bUppercaseFilter
                    End
                    Move stConstraint to aConstraint[iIndex]
                End_Procedure

                Procedure _DeleteConstraint tTQFilterSegment[] ByRef aFilters Integer iConstraint
                    Move (RemoveFromArray(aFilters,iConstraint)) to aFilters
                End_Procedure
        
        Procedure _CalculateJumpInOutConditionsStep01 tTableQuery ByRef stQ Integer ByRef iSegment Integer iSegments tOCIndex stIndex
            // 1: As long as we can consequetively provide EQ constraints on the segment, we copy the constraint to 
            //    both the JumpInValues and JumpOutValues (and disregard that constraint from then on)
            Integer iTable iIndex iColumn iConstraint
            Boolean bCont
            
            Move stQ.iTable to iTable
            Move stQ._stCompiled.iIndex to iIndex

            Move True to bCont

            While (bCont and iSegment<=iSegments)
                Move stIndex.aSegments[iSegment].iColumn to iColumn
                Get _FindConstraintEQ stQ.aFilters iTable iColumn False to iConstraint
                Move (iConstraint<>-1) to bCont
                If (bCont) Begin
                    If (not(stIndex.aSegments[iSegment].bUppercase)) Begin 
                        Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] False
                        Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] False
                        // UC-INDEX: copy filter on case-insentitive segment to stQ._stCompiled.aOtherConditions
                        Send _DeleteConstraint (&stQ.aFilters) iConstraint
                    End
                    Else Begin
                        Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] True
                        Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] True
                    End
                    
                    Increment iSegment
                End
            Loop
        End_Procedure

                Function _FindConstraintGEGT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
                    Integer iConstraint iConstraints iComp
                    Move (SizeOfArray(aFilters)-1) to iConstraints
                    For iConstraint from 0 to iConstraints
                        If (iTable=aFilters[iConstraint].stLeftValue.iTable and iColumn=aFilters[iConstraint].stLeftValue.iColumn) Begin
                            Move aFilters[iConstraint].iComp to iComp
                            If (iComp=tqGT or iComp=tqGE or (bAlsoEQ and iComp=tqEQ)) Begin
                                Function_Return iConstraint
                            End
                        End
                    Loop
                    Function_Return -1
                End_Function
                
                Function _FindConstraintLELT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
                    Integer iConstraint iConstraints iComp
                    Move (SizeOfArray(aFilters)-1) to iConstraints
                    For iConstraint from 0 to iConstraints
                        If (iTable=aFilters[iConstraint].stLeftValue.iTable and iColumn=aFilters[iConstraint].stLeftValue.iColumn) Begin
                            Move aFilters[iConstraint].iComp to iComp
                            If (iComp=tqLT or iComp=tqLE or (bAlsoEQ and iComp=tqEQ)) Begin
                                Function_Return iConstraint
                            End
                        End
                    Loop
                    Function_Return -1
                End_Function
                
        Procedure _CalculateJumpInOutConditionsStep02 tTableQuery ByRef stQ Integer ByRef iJumpInSegment Integer ByRef iJumpOutSegment Integer iSegments tOCIndex stIndex
            // 2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
            //    indepentdantly) we move the constraint to JumpInValues/JumpOutValues (and disregard that
            //    constraint from then on *unless* it's a jump-in constraint and the comperator is GT (or LT
            //    if it's a descending index segment))
            Integer iTable iIndex iColumn iConstraint
            Boolean bCont
            
            Move stQ.iTable to iTable
            Move stQ._stCompiled.iIndex to iIndex

            // Jump in
            If (iJumpInSegment<=iSegments) Begin
                Move stIndex.aSegments[iJumpInSegment].iColumn to iColumn
                If (stIndex.aSegments[iJumpInSegment].bDescending) Begin
                    Get _FindConstraintLELT stQ.aFilters iTable iColumn False to iConstraint
                    If (iConstraint<>-1) Begin
                        // UC-INDEX: if uppercased segment we must re-evaluate for each record, 
                        // and therefore we will keep the filter
                        If (not(stIndex.aSegments[iJumpInSegment].bUppercase)) Begin 
                            Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] False
                            If (stQ.aFilters[iConstraint].iComp=tqLE) Begin
                                Send _DeleteConstraint (&stQ.aFilters) iConstraint
                            End
                        End
                        Else Begin
                            Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] True
                        End
                        Increment iJumpInSegment
                    End
                    Else Begin
                        Move -1 to iJumpInSegment
                    End
                End
                Else Begin
                    Get _FindConstraintGEGT stQ.aFilters iTable iColumn False to iConstraint
                    If (iConstraint<>-1) Begin
                        // UC-INDEX: if uppercased segment we must re-evaluate for each record, 
                        // and therefore we will keep the filter
                        If (not(stIndex.aSegments[iJumpInSegment].bUppercase)) Begin 
                            Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] False
                            If (stQ.aFilters[iConstraint].iComp=tqGE) Begin
                                Send _DeleteConstraint (&stQ.aFilters) iConstraint
                            End
                        End
                        Else Begin
                            Send _AppendConstraint (&stQ._stCompiled.aJumpInValues) stQ.aFilters[iConstraint] True
                        End
                        Increment iJumpInSegment
                    End
                    Else Begin
                        Move -1 to iJumpInSegment
                    End
                End
            End
            
            // Jump out
            If (iJumpOutSegment<=iSegments) Begin
                Move stIndex.aSegments[iJumpOutSegment].iColumn to iColumn
                If (stIndex.aSegments[iJumpOutSegment].bDescending) Begin
                    Get _FindConstraintGEGT stQ.aFilters iTable iColumn False to iConstraint
                    If (iConstraint<>-1) Begin

                        // UC-INDEX: if uppercased segment we must re-evaluate for each record, 
                        // and therefore we will keep the filter
                        If (not(stIndex.aSegments[iJumpOutSegment].bUppercase)) Begin 
                            Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] False
                            Send _DeleteConstraint (&stQ.aFilters) iConstraint
                        End
                        Else Begin
                            // We jump out only when the uppercased column-value is greater than the uppercased filter-value
                            Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] True
                        End

                        Increment iJumpOutSegment
                    End
                    Else Begin
                        Move -1 to iJumpOutSegment
                    End
                End
                Else Begin
                    Get _FindConstraintLELT stQ.aFilters iTable iColumn False to iConstraint
                    If (iConstraint<>-1) Begin
                        // UC-INDEX: if uppercased segment we must re-evaluate for each record, 
                        // and therefore we will keep the filter
                        If (not(stIndex.aSegments[iJumpOutSegment].bUppercase)) Begin 
                            Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] False
                            Send _DeleteConstraint (&stQ.aFilters) iConstraint
                        End
                        Else Begin
                            // We jump out only when the uppercased column-value is greater than the uppercased filter-value
                            Send _AppendConstraint (&stQ._stCompiled.aJumpOutValues) stQ.aFilters[iConstraint] True
                        End
                        Increment iJumpOutSegment
                    End
                    Else Begin
                        Move -1 to iJumpOutSegment
                    End
                End
            End
        End_Procedure

        Procedure _CalculateJumpInOutConditions tTableQuery ByRef stQ
            Integer iSegment iSegments iTable iIndex iTempIndex
            Integer iJumpInSegment iJumpOutSegment
            Boolean bBackwards 
            tTQFilterSegment[] aBackupConstraints
            tOCIndex stIndex
            
            Move stQ.iTable to iTable
            Move stQ._stCompiled.iIndex to iIndex
            Move stQ._stCompiled.bBackwards to bBackwards
            Move stQ.aFilters to aBackupConstraints
            
            // If the scan index is not compatible with the output index we are forced to 
            // prefetch the record set in order to sort it before we "output" it:
            If (not(_IndexAgreement(Self,stQ,iIndex,True))) Begin

                // If the index is the exact uppersite we still consider the index in agreement.
                // Therefore we do not pass the information that the index is scanned backwards to 
                // the _IndexAgreement function.
                
                Move True to stQ._stCompiled.bPrefetch
                Move stQ._stCompiled._iLimit to stQ._stCompiled._iPushLimit 

                If (stQ._stCompiled.bBackwards) Begin // set to the opposite of what was tested above _IndexAgreement call
                    Move stQ._stCompiled.iIndex to iTempIndex
                End
                Else Begin
                    Move (stQ._stCompiled.iIndex+1000) to iTempIndex
                End

                If (stQ.iForceIndex=-1 and stQ.iLimit<>0 and _IndexAgreement(Self,stQ,iTempIndex,False)) Begin
                    // If tail and negated index is ok then we do _not_ reset the limit.
                End
                Else Begin
                    Move 0 to stQ._stCompiled._iLimit
                End
                
            End
            Else Begin
                Move 0 to stQ._stCompiled._iPushLimit
            End
                
            // Initialize:
            Move (ResizeArray(stQ._stCompiled.aJumpInValues,0)) to stQ._stCompiled.aJumpInValues
            Move (ResizeArray(stQ._stCompiled.aJumpOutValues,0)) to stQ._stCompiled.aJumpOutValues
            Move (ResizeArray(stQ._stCompiled.aOtherConditions,0)) to stQ._stCompiled.aOtherConditions
            
            Get IndexDefinition of oOverlapColumnFunctions stQ.iTable iIndex to stIndex
            Move (SizeOfArray(stIndex.aSegments)-1) to iSegments
        
            Move 0 to iSegment 
             
            // Calculating the JumpInValues:
            //     Starting with the most significant segment we go through the segments of the _stCompiled.iIndex
            //        1. As long as we can consequetively provide EQ constraints on the segment, we copy the 
            //           constraint to both the JumpInValues and JumpOutValues (and disregard that constraint 
            //           from then on)
                         Send _CalculateJumpInOutConditionsStep01 (&stQ) (&iSegment) iSegments stIndex
            //        2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
            //           respectively) we move the constraint to JumpInValues/JumpOutValues (and disregard that 
            //           constraint from then on)
                         Move iSegment to iJumpInSegment
                         Move iSegment to iJumpOutSegment
                         Send _CalculateJumpInOutConditionsStep02 (&stQ) (&iJumpInSegment) (&iJumpOutSegment) iSegments stIndex
            //        3. The constraints that are then left are copied to the aOtherConstraints array
                         Move stQ.aFilters to stQ._stCompiled.aOtherConditions
            Move aBackupConstraints to stQ.aFilters 
        End_Procedure

                        Procedure _IncrementJumpInOutCondition _tTQValueSource ByRef stValue Integer ByRef bIncrement Integer ByRef bCarry
                            Integer iMax
                            Move (SizeOfArray(stValue.aOrList)-1) to iMax
                        
                            If (iMax>=0) Begin // If it's an in-list // not-in-list would never make it here.
                                If (bIncrement or bCarry) Begin
                                    Increment stValue._iOrListPointer
                                    If (stValue._iOrListPointer>iMax) Begin
                                        Move True to bCarry
                                        Move 0 to stValue._iOrListPointer
                                    End
                                    Else Begin
                                        Move False to bCarry
                                    End
                                    Move False to bIncrement
                                End
                            End
                        End_Procedure
                        
                        Procedure _ResetOrListPointer _tTQValueSource ByRef stValue
                            If (SizeOfArray(stValue.aOrList)>0) Begin
                                Move 0 to stValue._iOrListPointer
                            End
                        End_Procedure

                Function _IncrementJumpInOutConditions tTableQuery ByRef stQ Integer iJumpOutTriggerIndex Returns Boolean
                    // This function increments jump-in/out pointers and returns false if pointers could not
                    // be incremented. The pointers are into arrays of or-list values
                    // Parameter iJumpOutTriggerIndex points to the constrain segment that triggered the jump-out
                    // that in turn triggered the call of this function.
                    // The or-list pointers to the left of (and including) iJumpOutTriggerIndex must be incremented
                    // while the or-list pointers to the right must be reset.
                    Integer iItem iMax iIndex
                    Boolean bCarry bIncrement bSuccess bReturnFalse
                    Move (SizeOfArray(stQ._stCompiled.aJumpOutValues)-1) to iMax

                    Move False to bReturnFalse

                    If (iJumpOutTriggerIndex>=0) Begin
                        // Increment pointers to the left
                        Move False to bCarry
                        Move True to bIncrement
                        // Only if there are any jumpout values to increment upon:
                        If (SizeOfArray(stQ._stCompiled.aJumpOutValues)>0) Begin 
                            For iItem from 0 to iJumpOutTriggerIndex // min iMax) // 07-04-2016 iMax added
                                Move (iJumpOutTriggerIndex-iItem) to iIndex // Go throught it backwards (least significant first)
                                Send _IncrementJumpInOutCondition (&stQ._stCompiled.aJumpOutValues[iIndex].stRightValue) (&bIncrement) (&bCarry)
                            Loop
                        End
                        Move (not(bCarry) and not(bIncrement)) to bSuccess
                    End
                    Else Begin
                        Move True to bSuccess
                        Move True to bReturnFalse
                    End
                    // Reset the or-lists to the lessor significant side of iJumpOutTriggerIndex
                    If (bSuccess) Begin
                        For iItem from (iJumpOutTriggerIndex+1) to iMax
                            Send _ResetOrListPointer (&stQ._stCompiled.aJumpOutValues[iItem].stRightValue)
                        Loop
                    End

                    If (bReturnFalse) Begin
                        // The point is that no-way will we return true if nothing was actually incremented
                        Function_Return False
                    End

                    Function_Return bSuccess
                End_Function

                Procedure _SortVariantArray String[] ByRef aValues Integer iType Boolean bReverseArray
                    Integer iMax iItem
                    String[] aStringValues
                    Number[] aNumberValues
                    Date[] aDateValues
                    DateTime[] aDateTimeValues

                    Move (SizeOfArray(aValues)-1) to iMax
                    If (iType=tqSTRING or iType=tqTEXT) Begin
                        Move (SortArray(aValues)) to aValues
                    End
                    Else If (iType=tqNUMBER) Begin
                        For iItem from 0 to iMax
                            Move aValues[iItem] to aNumberValues[iItem]
                        Loop
                        Move (SortArray(aNumberValues)) to aNumberValues
                        For iItem from 0 to iMax
                            Move aNumberValues[iItem] to aValues[iItem]
                        Loop
                    End
                    Else If (iType=tqDATE) Begin
                        For iItem from 0 to iMax
                            Move aValues[iItem] to aDateValues[iItem]
                        Loop
                        Move (SortArray(aDateValues)) to aDateValues
                        For iItem from 0 to iMax
                            Move aDateValues[iItem] to aValues[iItem]
                        Loop
                    End
                    Else If (iType=tqDATETIME) Begin
                        For iItem from 0 to iMax
                            Move aValues[iItem] to aDateTimeValues[iItem]
                        Loop
                        Move (SortArray(aDateTimeValues)) to aDateTimeValues
                        For iItem from 0 to iMax
                            Move aDateTimeValues[iItem] to aValues[iItem]
                        Loop
                    End

                    If (bReverseArray) Begin
                        Move (ReverseArray(aValues)) to aValues
                    End
                End_Procedure
                
                    Function _SortSegmentReversed tTableQuery stQ _tTQValueSource stLeftValue Returns Boolean
                        Integer iItem iMax
                        Move (SizeOfArray(stQ.aOrdering)-1) to iMax
                        For iItem from 0 to iMax
                            If (stQ.aOrdering[iItem].stValueSource.iTable=stQ.iTable and ;
                                stQ.iTable=stLeftValue.iTable and ;
                                stQ.aOrdering[iItem].stValueSource.iColumn=stLeftValue.iColumn) Begin
                                    Function_Return stQ.aOrdering[iItem].bDescending
                            End
                        Loop
                    End_Function

                Procedure _SortOrListValues tTableQuery ByRef stQ   
                    // Sorting the OrList values serves two purposes:
                    // 1: The rows will be found in the order specified by the scan index
                    // 2: The mechanism that determines which OrList to "increment" will be confused
                    //    if the OrList values do not appear in sequence (it's the break level
                    //    computation that will go wrong)
                    Boolean bReverseArray
                    Integer iItem iMax
                    // As said elsewhere: not-in-list filters would never make it here (they can't be optimized).
                    Move (SizeOfArray(stQ._stCompiled.aJumpInValues)-1) to iMax
                    For iItem from 0 to iMax
                        // Should we sort backwards?
                        Get _SortSegmentReversed stQ stQ._stCompiled.aJumpInValues[iItem].stLeftValue to bReverseArray
                        Send _SortVariantArray (&stQ._stCompiled.aJumpInValues[iItem].stRightValue.aOrList) stQ._stCompiled.aJumpInValues[iItem].stLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(stQ._stCompiled.bBackwards)=1)
                    Loop
                    Move (SizeOfArray(stQ._stCompiled.aJumpOutValues)-1) to iMax
                    For iItem from 0 to iMax
                        // Should we sort backwards?
                        Get _SortSegmentReversed stQ stQ._stCompiled.aJumpOutValues[iItem].stLeftValue to bReverseArray
                        Send _SortVariantArray (&stQ._stCompiled.aJumpOutValues[iItem].stRightValue.aOrList) stQ._stCompiled.aJumpOutValues[iItem].stLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(stQ._stCompiled.bBackwards)=1)
                    Loop
                End_Procedure
                
                Function _CanFindIndexInRatings _tTQIndexRating[] aIndexRatings Integer iIndex Boolean ByRef bBackwards Number ByRef nENR Returns Boolean
                    Integer iItem iMax
                    Move (SizeOfArray(aIndexRatings)-1) to iMax
                    For iItem from 0 to iMax
                        If (iIndex=aIndexRatings[iItem].iIndex or (iIndex+1000)=aIndexRatings[iItem].iIndex) Begin
                            Move (aIndexRatings[iItem].iIndex>1000) to bBackwards
                            Move aIndexRatings[iItem].nExpectedNumberRows to nENR
                            Function_Return True
                        End
                    Loop
                    Function_Return False
                End_Function

            Function SQLSelectStatement tTableQuery stQ Returns String
                Handle hoSqlBuilder
                String sStatement
                Send _TableRelateStatesReset (&stQ)
                If (stQ.sForceSQLStatement<>"") Begin
                    Function_Return stQ.sForceSQLStatement
                End
                Get phoSqlBuilder to hoSqlBuilder
                Get TableQuerySelectStatement of hoSqlBuilder stQ to sStatement
                Function_Return sStatement
            End_Function
            
//            Function SQLDeleteStatement tTableQuery stQ Returns String
//                Handle hoSQLGenerator
//                String sStatement
//                Send _TableRelateStatesReset (&stQ)
//                Get phoSqlBuilder to hoSQLGenerator
//                Get _SQLDeleteStatement of hoSQLGenerator stQ Self to sStatement
//                Function_Return sStatement
//            End_Function

                // Used by TableQueryStructureFunctions.pkg
                Procedure _ReadParentSortValues tTableQuery ByRef strParentQuery tTableQuery ByRef strChildQuery
                    Integer iItem iItemMax
                    String sValue
                    String[] aValues
                    Move (SizeOfArray(strParentQuery.aOrdering)-1) to iItemMax
                    For iItem from 0 to iItemMax
                        Get ResultColumnValue (&strParentQuery) strParentQuery.aOrdering[iItem].stValueSource.iTable strParentQuery.aOrdering[iItem].stValueSource.iColumn to sValue
                        If (strParentQuery.aOrdering[iItem].bUppercase=1) Begin // -1:don't care, 0:no, 1:yes
                            Move (Uppercase(sValue)) to sValue
                        End
                        Move sValue to aValues[iItem]
                    Loop
                    Move aValues to strChildQuery._stControlBlock.stInnerJoinCB.aCurrentParentSortValues
                End_Procedure

//            Global_Variable Integer _giSQLHandleCheckIndent
//            Move 0 to _giSQLHandleCheckIndent
//            Procedure ShowInit tSQLStatementHandle strStatement Integer iTable
//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Initialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
//                Increment _giSQLHandleCheckIndent
//            End_Procedure
//            Procedure ShowDeInit tSQLStatementHandle strStatement Integer iTable
//                Decrement _giSQLHandleCheckIndent
//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Deinitialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
//            End_Procedure

            Function _InitializeQuery tTableQuery ByRef stQ Returns Boolean
                Integer iTable iPrefetchCount iPrefetchTimeout
                Integer iDecimalSeparator iDriverIndex
                Integer iMax iItem
                String sDriver sStatement
                tSQLStatementHandle strStatement
                If (not(stQ._stControlBlock.bInitialized)) Begin
                    Move True to stQ._stControlBlock.bInitialized
                    
                    If (stQ.bRestoreRecordBuffersOnQueryCompletion) Begin
                        Send _PushNoneFixedBuffers stQ
                    End
                    
                    Move stQ.iTable to iTable
                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
                    
                    If (stQ._stControlBlock.iQueryMethod=tqSQLPKG) Begin
                        If (not(stQ._stControlBlock.stInnerJoinCB.bEnabled) or not(stQ._stControlBlock.stInnerJoinCB.bInitialized)) Begin
                            
                            If (OpenStatementOnTable(oSQLStatementHandles,stQ.iTable,&strStatement)) Begin
                                Move strStatement to stQ._stControlBlock.stSQLStatementHandle

                                Send _TableRelateStatesReset (&stQ)
                                Get SQLSelectStatement stQ Self to sStatement
//                                Move (ToANSI(sStatement)) to sStatement
                                Send SQLExecDirect of strStatement.hStatHandle sStatement
                                
//                                If (IsDebuggerPresent()) Begin
//                                    Showln ("SQLExecDirect: "+sStatement)
//                                End
                                
                                Move (SizeOfArray(stQ.aOutputColumns)-1) to iMax
                                For iItem from 0 to iMax
                                    If (stQ.aOutputColumns[iItem].iTable>0 and stQ.aOutputColumns[iItem].iColumn=0) Begin
                                        Send SQLFetchActivatesBuffer of strStatement.hStatHandle stQ.aOutputColumns[iItem].iTable True // True: DF_FILE_ACTIVATE will be true
                                    End
                                Loop
                                
                                If (stQ._stControlBlock.stInnerJoinCB.bEnabled) Begin
                                    Move True to stQ._stControlBlock.stInnerJoinCB.bInitialized
                                    Move False to stQ._stControlBlock.stInnerJoinCB.bSkipNextFetch
                                    Move False to stQ._stControlBlock.stInnerJoinCB.bEndOfResultSet
                                End
                            End
                            
                        End
                    End
                    Else Begin
                        If ((sDriver<>"DATAFLEX") and (sDriver <> "DFBTRDRV")) Begin // We're on an SQL backend
                            // This means that we have been 'forced' to use the record oriented
                            // interface but we are in fact an SQL table and therefore we might
                            // might want to tamper with the prefetch cache settings:
                            If (stQ._stControlBlock.stSQLCacheControl.bUseSettings) Begin
                                Move stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
                                Move stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
                                If (iPrefetchCount<>0) Begin
                                    Get_Attribute DF_FILE_BLOCK_SIZE of iTable to stQ._stControlBlock._stPreviousSQLCacheControl.iPrefetchRecordCount
                                    Set_Attribute DF_FILE_BLOCK_SIZE of iTable to iPrefetchCount
                                End
                                If (iPrefetchTimeout<>0) Begin
                                    Get TableCacheTimeout of oTableDriverFunctions iTable to stQ._stControlBlock._stPreviousSQLCacheControl.iPrefetchRecordTimeout
                                    Set TableCacheTimeout of oTableDriverFunctions iTable to iPrefetchTimeout
                                End
                            End
                        End
                    End
                End
                Function_Return (stQ._stControlBlock.bInitialized)
            End_Function

            Procedure _DeinitializeQuery tTableQuery ByRef stQ
                Integer iTable iPrefetchCount iPrefetchTimeout iMax iItem
                String sDriver
                If (stQ._stControlBlock.iQueryMethod=tqSQLPKG) Begin
                    If (not(stQ._stControlBlock.stInnerJoinCB.bInitialized)) Begin // inner join => don't close the statement
//                    Send ShowDeInit stQ._stControlBlock.stSQLStatementHandle stQ.iTable
                        Move (SizeOfArray(stQ.aOutputColumns)-1) to iMax
                        For iItem from 0 to iMax
                            If (stQ.aOutputColumns[iItem].iTable>0 and stQ.aOutputColumns[iItem].iColumn=0) Begin
                                Send SQLFetchActivatesBuffer of stQ._stControlBlock.stSQLStatementHandle.hStatHandle stQ.aOutputColumns[iItem].iTable False // False: default behavior.
                            End
                        Loop
                        Send CloseStatement of oSQLStatementHandles stQ._stControlBlock.stSQLStatementHandle
                    End
                End
                Else Begin
                    Move stQ.iTable to iTable
                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
                    If ((sDriver<>"DATAFLEX") and (sDriver <> "DFBTRDRV")) Begin // We're on an SQL backend
                        // This means that we have been 'forced' to use the record oriented
                        // interface but we are in fact an SQL table and therefore we want
                        // to restore the prefetch cache settings (if they were originally set):
                        If (stQ._stControlBlock.stSQLCacheControl.bUseSettings) Begin
                            Move stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
                            Move stQ._stControlBlock.stSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
                            If (iPrefetchCount<>0) Begin // Only then did we change it in the first place
                                // Reset prefetch setting
                                Set_Attribute DF_FILE_BLOCK_SIZE of iTable to stQ._stControlBlock._stPreviousSQLCacheControl.iPrefetchRecordCount
                            End
                            If (iPrefetchTimeout<>0) Begin // Only then did we change it in the first place
                                // Restore cache time out setting
                                Set TableCacheTimeout of oTableDriverFunctions iTable to stQ._stControlBlock._stPreviousSQLCacheControl.iPrefetchRecordTimeout
                            End
                        End
                    End
                End
            End_Procedure

                Function _QueryMethodSQL tTableQuery stQ Returns Boolean
                    String sDriver
                    Integer iQueryMethod
                    Move tqDATAFLEX to iQueryMethod
                    If (not(stQ.bNoESQL)) Begin
                        Get_Attribute DF_FILE_DRIVER of stQ.iTable to sDriver
                        If (sDriver="MSSQLDRV") Begin
                            Move tqSQLPKG to iQueryMethod
                        End
                    End
                    Function_Return (iQueryMethod<>tqDATAFLEX)
                End_Function

    Procedure OnApplyGlobalFilters tTableQuery ByRef stQ
    End_Procedure

            Function _CompileQuery tTableQuery ByRef stQ Returns Boolean
                Boolean bBackwards
                Boolean[] aSortDescending
                Number nENR
                Number[] aColumnRatings
                String sDriver sFormat
                _tTQIndexRating stRating
                _tTQIndexRating[] aIndexRatings
                tTQFilterSegment[] aTemp

                If (not(stQ._stControlBlock.bCompiled)) Begin                    
                    Send OnApplyGlobalFilters (&stQ)
                    If (_ValidateQuery(Self,stQ)) Begin
                        
                        // Determine query method:
                        Move tqDATAFLEX to stQ._stControlBlock.iQueryMethod 
                        If (not(stQ.bNoESQL)) Begin
                            Get_Attribute DF_FILE_DRIVER of stQ.iTable to sDriver
                            If (sDriver="MSSQLDRV") Begin
                                Move tqSQLPKG to stQ._stControlBlock.iQueryMethod
                                Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of stQ.iTable to sFormat
                                Move (sFormat<>"OEM") to stQ._stControlBlock.bSQLTableIsAnsi
                            End
                        End
                        
                        If (stQ._stControlBlock.iQueryMethod=tqDATAFLEX) Begin

                            Move False to stQ._stCompiled.bBackwards
                            
                            Move stQ.bForcePrefetch to stQ._stCompiled.bPrefetch
                
                            Get _CalculateIndex (&stQ) to aIndexRatings
                            
                            If (stQ.iForceIndex<>-1) Begin
                                If (_CanFindIndexInRatings(Self,aIndexRatings,stQ.iForceIndex,&bBackwards,&nENR)) Begin
                                    Move stQ.iForceIndex to stQ._stCompiled.iIndex
                                    Move bBackwards to stQ._stCompiled.bBackwards
                                    Move nENR to stQ._stCompiled.nENR
                                End
                                Else Begin
                                    Send OnError 721 "Illegal index forced"
                                End
                            End
        
                            If (stQ.iLimit>=0) Begin
                                Move stQ.iLimit to stQ._stCompiled._iLimit
                            End
                            Else Begin 
                                // If limit is -3 for example, we only want the 3 last rows of the 
                                // set. In this case we instruct TableQuery to reverse the ordering 
                                // and return the first three. Hokus pokus. (and then of course they
                                // will be occurring in the wrong order). ((deal with that later))
                                Move (-stQ.iLimit) to stQ._stCompiled._iLimit
                                Move (not(stQ._stCompiled.bBackwards)) to stQ._stCompiled.bBackwards // reverse index search
                            End

                            Send OnIndexCalculated stQ aIndexRatings

                            Send _CalculateJumpInOutConditions (&stQ)

                            Send _SortOrListValues (&stQ) // Make sure that values occur in the sequence they would be if occurring in an index

                            If (stQ._stCompiled.bBackwards) Begin // If backwards, we swap jump-in and jump-out conditions
                                Move stQ._stCompiled.aJumpInValues to aTemp
                                Move stQ._stCompiled.aJumpOutValues to stQ._stCompiled.aJumpInValues
                                Move aTemp to stQ._stCompiled.aJumpOutValues
                            End
                        End

                        Move True to stQ._stControlBlock.bCompiled
                    End
                    Move False to stQ._stControlBlock.bInitialized
                End
                Function_Return (stQ._stControlBlock.bCompiled)
            End_Function

    //> This will analyse the query and calculate a query strategy. The strategy may be
    //> inspected by inspecting the values of stQ members
    Function CompileQuery tTableQuery ByRef stQ Returns Boolean
        Move False to stQ._stControlBlock.bCompiled
        Get _CompileQuery (&stQ) to stQ._stControlBlock.bInitialized
        If (stQ._stControlBlock.bInitialized) Begin
            Send _TableRelateStatesReset (&stQ)
        End
        Function_Return stQ._stControlBlock.bInitialized
    End_Function

        Function _ValueSourceValue tTableQuery ByRef stQ _tTQValueSource stValue Returns String
            Integer iColumn hoExprParser iMax iItem
            Integer[] aTables // (in expression)
            Number nValue
            String sValue
            tXPGrammar stGrammar
            tXPError stError
            tXPValue stXPValue
            
            If (stValue.iTable<>0) Begin // table column reference
                If (stValue.iTable<>stQ.iTable) Begin // Only called when dataflex handling
                    Send _RelateToTable (&stQ) stValue.iTable
                End
                Move stValue.iColumn to iColumn
                If (iColumn=0) Begin
                    Move (SerializeRowID(GetRowID(stValue.iTable))) to sValue
                End
                Else Begin
                    Get_Field_Value stValue.iTable iColumn to sValue
                    Move (Rtrim(sValue)) to sValue
                End
            End
            Else If (SizeOfArray(stValue.aSymbols)>0) Begin // Expression

                Get phoExprParser to hoExprParser
                Get NewGrammar of hoExprParser to stGrammar
                
                // Make sure that tables that are referenced in the expression is
                Get HintedTables of hoExprParser stValue.aSymbols to aTables
                Move (SizeOfArray(aTables)-1) to iMax
                For iItem from 0 to iMax
                    If (aTables[iItem]<>stQ.iTable) Begin // Only called when dataflex handling
                        Send _RelateToTable (&stQ) aTables[iItem]
                    End
                Loop

                Get Evaluate of hoExprParser stGrammar stValue.aSymbols (&stError) to stXPValue
                
                If (stError.sErrorText="") Begin
                    Move stXPValue.sValue to sValue
                    If (stValue.iType=tqNUMBER) Begin
                        Move sValue to nValue
                        Move (NumberToString(oStringFunctions,nValue,2)) to sValue
                    End
                End
                Else Begin
                    Move stError.sErrorText to sValue
                End
                
            End
            Else If (stValue.hFunction<>0) Begin
                Get stValue.hFunction of stValue.hObject stValue.iColumn to sValue
            End
            Else If (SizeOfArray(stValue.aOrList)>0) Begin
                Move stValue.aOrList[stValue._iOrListPointer] to sValue
            End
            Else Begin
                Move stValue.sConstant to sValue
            End
            If (stValue.iType=tqNUMBER and sValue="") Begin
                Move "0" to sValue
            End
            Function_Return sValue
        End_Function

            Function _ValueSourceScriptValueOrListFormat String[] aOrList Integer iType Returns String
                Integer iItem iMax
                Boolean bOk
                String sValue
                If (iType=tqSTRING or iType=tqTEXT) Begin
                    Move (SizeOfArray(aOrList)-1) to iMax
                    Move True to bOk
                    For iItem from 0 to iMax
                        If (bOk) Begin
                            Get AddQuotes of oStringFunctions (&aOrList[iItem]) "'" to bOk
                        End
                    Loop
                    If (bOk) Begin
                        Get JoinString aOrList "," 0 0 to sValue
                        Move ("("+sValue+")") to sValue
                    End
                    Else Begin
                        Move "" to sValue // Signals an error
                    End
                End
                Else Begin
                    Get JoinString aOrList "," 0 0 to sValue
                    Move ("("+sValue+")") to sValue
                End
                Function_Return sValue
            End_Function

        Function _ValueSourceDisplayValue tTableQuery ByRef stQ _tTQValueSource stValue Returns String // Called by TQ test facility in VDFxray
            Integer iMax iItem
            String sValue
            Move (SizeOfArray(stValue.aOrList)-1) to iMax
            If (iMax>=0) Begin
                For iItem from 0 to iMax
                    Move (sValue+stValue.aOrList[iItem]) to sValue
                    If (iItem<>iMax) Begin
                        Move (sValue+" ; ") to sValue
                    End
                Loop
            End
            Else Begin
                Get _ValueSourceValue (&stQ) stValue to sValue
            End
            Function_Return sValue
        End_Function
            
        Procedure _AssignConstraintValues tTableQuery ByRef stQ tTQFilterSegment[] ByRef aFilters
            Integer iMax iIndex
            Move (SizeOfArray(aFilters)-1) to iMax
            For iIndex from 0 to iMax
                // If it's a contraint by a table column value and if the table is not fixed we do not bother to assign
                // initial values. Instead we "calculate" them on each record.
                If (aFilters[iIndex].stRightValue.iTable=0 or _IsTableFixed(Self,stQ,aFilters[iIndex].stRightValue.iTable)) Begin
                    Get _ValueSourceValue (&stQ) aFilters[iIndex].stRightValue to aFilters[iIndex].stRightValue._sValue
                    If (aFilters[iIndex].iComp=tqMATCH) Begin
                        Get WildCardEvalSequence of oStringFunctions aFilters[iIndex].stRightValue._sValue to aFilters[iIndex].stMatchEvalSequence
                    End
                    If (aFilters[iIndex].iComp=tqUCMATCH) Begin
                        Get WildCardEvalSequence of oStringFunctions (Uppercase(aFilters[iIndex].stRightValue._sValue)) to aFilters[iIndex].stMatchEvalSequence
                    End
                End
            Loop
        End_Procedure
        
        Procedure _ReassignJumpInOutConstraintValues tTableQuery ByRef stQ tTQFilterSegment[] ByRef aJumpInConstraints tTQFilterSegment[] ByRef aJumpOutConstraints
            Integer iTable iColumn iJumpOutItem
            _tTQValueSource stSource
            String sValue
            Integer iItem iMax
            Move (SizeOfArray(aJumpOutConstraints)-1) to iMax
            For iItem from 0 to iMax
                If (SizeOfArray(aJumpOutConstraints[iItem].stRightValue.aOrList)>0) Begin // Must be in-list (not-in-list) are not used for optimizing
                    Move aJumpOutConstraints[iItem].stLeftValue.iTable to iTable
                    Move aJumpOutConstraints[iItem].stLeftValue.iColumn to iColumn
                    Move aJumpOutConstraints[iItem].stRightValue to stSource
                    Get _ValueSourceValue (&stQ) stSource to sValue
                    Move sValue to aJumpOutConstraints[iItem].stRightValue._sValue
                    Get _FindConstraintEQ aJumpInConstraints iTable iColumn True to iJumpOutItem
                    If (iJumpOutItem>-1) Begin
                        Move sValue to aJumpInConstraints[iJumpOutItem].stRightValue._sValue
                    End
                    Else Begin
                        Send OnError 722 "Unmatched jumpin or-list (should have been matched in jump-out constraints)"
                    End
                End
            Loop
        End_Procedure

                Function _SharpenJumpInValue String sValue Integer iTable Integer iColumn Boolean bDescending Returns String
                    // NOTE: If the function does not succeed in sharpening the value, no harm
                    // is done (other than some potentially unnescessary finds).
                    Integer iDFType iLen iDecs
                    Number nValue
                    Date dValue
                    DateTime dtValue

                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iDFType
                    Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLen
                    Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iDecs

                    If (iDFType=DF_BCD) Begin
                        Move sValue to nValue
                        // OBS! Here we need a check that we do not in- or decrement the value out of range
                        If (bDescending) Begin
                            If (iDecs=0) Begin
                                Move (nValue-1) to nValue
                            End
                            Else If (iDecs=1) Begin
                                Move (nValue-0.1) to nValue
                            End
                            Else If (iDecs=2) Begin
                                Move (nValue-0.01) to nValue
                            End
                            Else If (iDecs=3) Begin
                                Move (nValue-0.001) to nValue
                            End
                            Else If (iDecs=4) Begin
                                Move (nValue-0.0001) to nValue
                            End
                            Else If (iDecs=5) Begin
                                Move (nValue-0.00001) to nValue
                            End
                            Else If (iDecs=6) Begin
                                Move (nValue-0.000001) to nValue
                            End
                            Else If (iDecs=7) Begin
                                Move (nValue-0.0000001) to nValue
                            End
                            Else If (iDecs=8) Begin
                                Move (nValue-0.00000001) to nValue
                            End
                        End
                        Else Begin
                            If (iDecs=0) Begin
                                Move (nValue+1) to nValue
                            End
                            Else If (iDecs=1) Begin
                                Move (nValue+0.1) to nValue
                            End
                            Else If (iDecs=2) Begin
                                Move (nValue+0.01) to nValue
                            End
                            Else If (iDecs=3) Begin
                                Move (nValue+0.001) to nValue
                            End
                            Else If (iDecs=4) Begin
                                Move (nValue+0.0001) to nValue
                            End
                            Else If (iDecs=5) Begin
                                Move (nValue+0.00001) to nValue
                            End
                            Else If (iDecs=6) Begin
                                Move (nValue+0.000001) to nValue
                            End
                            Else If (iDecs=7) Begin
                                Move (nValue+0.0000001) to nValue
                            End
                            Else If (iDecs=8) Begin
                                Move (nValue+0.00000001) to nValue
                            End
                        End
                        Move nValue to sValue
                    End
                    Else If (iDFType=DF_DATE) Begin
                        Move sValue to dValue
                        If (bDescending) Begin
                            If (Integer(dValue>0)) Begin
                                Get DateIncrement of oDateFunctions dValue DS_DAY -1 to dValue
                            End
                        End
                        Else Begin
                            If (dValue<LargestPossibleDate) Begin
                                Get DateIncrement of oDateFunctions dValue DS_DAY 1 to dValue
                            End
                        End
                        Move dValue to sValue
                    End
                    Else If (iDFType=DF_DATETIME) Begin
                        Move sValue to dtValue
                        // OBS. Here we need a check that we do not in- or decrement the value out of range
                        If (bDescending) Begin
                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND -1 to dtValue
                        End
                        Else Begin
                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND 1 to dtValue
                        End
                        Move dtValue to sValue
                    End
                    Else If (iDFType=DF_ASCII) Begin
                        // This involves knowing the collate sequence of the DB and this we
                        // can only know that for sure if the driver is "DATAFLEX". (clue: Get CurrentCollateString of oVdfRuntimeFunctions)
                    End
                    Function_Return sValue
                End_Function

        // UC-INDEX:
        // 01-11-2023: uppercased index segment presents a problem because the "normal" jump in/out mechanism
        // can not predict the sequence of records found with respect to uppercased segments.
        //
        
        
        Procedure _SeedRecordBuffer tTableQuery stQ
            Boolean bIndexSeedSharpeningEnabled bBackwards
            Integer iMax iMax2 iIndex iTable iColumn
            String sValue
            tTQFilterSegment[] aFilters
            tocIndex stIndex

            Move stQ._stCompiled.bIndexSeedSharpeningEnabled to bIndexSeedSharpeningEnabled

            Move stQ._stCompiled.aJumpInValues to aFilters

            Move (SizeOfArray(aFilters)-1) to iMax
            For iIndex from 0 to iMax
                Move aFilters[iIndex].stLeftValue.iTable to iTable
                Move aFilters[iIndex].stLeftValue.iColumn to iColumn
                Move aFilters[iIndex].stRightValue._sValue to sValue
                
                // UC-INDEX:
                // At this point we need to find out if the finding index has bUppercased true
                // on a segment representing the column filtered by the current filter.

                If (bIndexSeedSharpeningEnabled) Begin
                    If (aFilters[iIndex].iComp=tqLT) Begin // Attempt to sharpen jump-in value on descending segment
                        Get _SharpenJumpInValue sValue iTable iColumn True to sValue
                    End
                    Else If (aFilters[iIndex].iComp=tqGT) Begin // Attempt to sharpen jump-in value on ascending segment
                        Get _SharpenJumpInValue sValue iTable iColumn False to sValue
                    End
                End

                Set_Field_Value iTable iColumn to sValue
            Loop

            Get IndexDefinition of oOverlapColumnFunctions stQ.iTable stQ._stCompiled.iIndex to stIndex
            Move (SizeOfArray(stIndex.aSegments)-1) to iMax2
            For iIndex from (iMax+1) to iMax2
                Move ((Integer(stQ._stCompiled.bBackwards)+Integer(stIndex.aSegments[iIndex].bDescending))=1) to bBackwards // xor
                If (stIndex.aSegments[iIndex].iColumn>0 or bBackwards) Begin // Don't seed a negative recnum !!!!
                    Send SeedMinValue of oIndexFunctions stQ.iTable stIndex.aSegments[iIndex].iColumn (bBackwards)
                End
            Loop
        End_Procedure

            Function _TestNumber Number nValueLeft Integer iComp Number nValueRight Returns Boolean
                If (iComp=tqEQ) Begin
                    Function_Return (nValueLeft =  nValueRight)
                End
                If (iComp=tqLT) Begin
                    Function_Return (nValueLeft <  nValueRight)
                End
                If (iComp=tqLE) Begin
                    Function_Return (nValueLeft <= nValueRight)
                End
                If (iComp=tqGE) Begin
                    Function_Return (nValueLeft >= nValueRight)
                End
                If (iComp=tqGT) Begin
                    Function_Return (nValueLeft >  nValueRight)
                End
                If (iComp=tqNE) Begin
                    Function_Return (nValueLeft <> nValueRight)
                End
                Function_Return False
            End_Function

        Function CompareNumbers Number nValueLeft Integer iComp Number nValueRight Returns Boolean
            Function_Return (_TestNumber(Self,nValueLeft,iComp,nValueRight))
        End_Function

            Function _TestString String sValueLeft Integer iComp tWildCardEvalSequence strMatchSequence String sValueRight Returns Boolean
                If (iComp=tqEQ) Begin
                    Function_Return (sValueLeft =  sValueRight)
                End
                If (iComp=tqLT) Begin
                    Function_Return (sValueLeft <  sValueRight)
                End
                If (iComp=tqLE) Begin
                    Function_Return (sValueLeft <= sValueRight)
                End
                If (iComp=tqGE) Begin
                    Function_Return (sValueLeft >= sValueRight)
                End
                If (iComp=tqGT) Begin
                    Function_Return (sValueLeft >  sValueRight)
                End
                If (iComp=tqNE) Begin
                    Function_Return (sValueLeft <> sValueRight)
                End
//                If (iComp=tqCONTAINS) Function_Return (sValueLeft contains sValueRight)
//                If (iComp=tqIN) Begin
//                    If sValueLeft in sValueRight Begin
//                        Function_Return True
//                    End
//                End
                If (iComp=tqMATCH) Begin
                    Function_Return (WildCardMatch(oStringFunctions,sValueLeft,strMatchSequence))
                End
                If (iComp=tqUCMATCH) Begin
                    Function_Return (WildCardMatch(oStringFunctions,Uppercase(sValueLeft),strMatchSequence))
                End
                Function_Return False
            End_Function

            Function _TestText String sValueLeft Integer iComp tWildCardEvalSequence stMatchSequence String sValueRight Returns Boolean
                Function_Return (_TestString(Self,sValueLeft,iComp,stMatchSequence,sValueRight))
            End_Function

            Function _TestDate Date dValueLeft Integer iComp Date dValueRight Returns Boolean
                If (iComp=tqEQ) Begin
                    Function_Return (dValueLeft =  dValueRight)
                End
                If (iComp=tqLT) Begin
                    Function_Return (dValueLeft <  dValueRight)
                End
                If (iComp=tqLE) Begin
                    Function_Return (dValueLeft <= dValueRight)
                End
                If (iComp=tqGE) Begin
                    Function_Return (dValueLeft >= dValueRight)
                End
                If (iComp=tqGT) Begin
                    Function_Return (dValueLeft >  dValueRight)
                End
                If (iComp=tqNE) Begin
                    Function_Return (dValueLeft <> dValueRight)
                End
                Function_Return False
            End_Function

            Function _TestDateTime DateTime dtValueLeft Integer iComp DateTime dtValueRight Returns Boolean
                If (iComp=tqEQ) Begin
                    Function_Return (dtValueLeft =  dtValueRight)
                End
                If (iComp=tqLT) Begin
                    Function_Return (dtValueLeft <  dtValueRight)
                End
                If (iComp=tqLE) Begin
                    Function_Return (dtValueLeft <= dtValueRight)
                End
                If (iComp=tqGE) Begin
                    Function_Return (dtValueLeft >= dtValueRight)
                End
                If (iComp=tqGT) Begin
                    Function_Return (dtValueLeft >  dtValueRight)
                End
                If (iComp=tqNE) Begin
                    Function_Return (dtValueLeft <> dtValueRight)
                End
                Function_Return False
            End_Function

            Function _EvaluateFilter tTableQuery ByRef stQ tTQFilterSegment stFilter Boolean bListCheckAll Returns Boolean
                Integer iType iOrListMax iOrListIndex
                Boolean bEval bFoundInList
                String sLeftValue sRightValue

                Get _ValueSourceValue (&stQ) stFilter.stLeftValue to sLeftValue
                Move stFilter.stLeftValue.iType to iType

                Move (SizeOfArray(stFilter.stRightValue.aOrList)-1) to iOrListMax
                If ((bListCheckAll or stFilter.iComp=tqNE) and iOrListMax>=0) Begin // not-in-list must always be evaluated 
                    Move False to bFoundInList
                    For iOrListIndex from 0 to iOrListMax
                        If (not(bFoundInList)) Begin
                            If (iType=tqSTRING) Begin
                                If (stFilter.bUppercaseFilter) Begin
                                    Get _TestString   (Uppercase(sLeftValue)) stFilter.iComp stFilter.stMatchEvalSequence (Uppercase(stFilter.stRightValue.aOrList[iOrListIndex])) to bFoundInList
                                End
                                Else Begin
                                    Get _TestString   sLeftValue stFilter.iComp stFilter.stMatchEvalSequence stFilter.stRightValue.aOrList[iOrListIndex] to bFoundInList
                                End
                            End
                            Else If (iType=tqNUMBER) Begin
                                Get _TestNumber   sLeftValue stFilter.iComp stFilter.stRightValue.aOrList[iOrListIndex] to bFoundInList
                            End
                            Else If (iType=tqTEXT) Begin
                                If (stFilter.bUppercaseFilter) Begin
                                    Get _TestText (Uppercase(sLeftValue)) stFilter.iComp stFilter.stMatchEvalSequence (Uppercase(stFilter.stRightValue.aOrList[iOrListIndex])) to bFoundInList
                                End
                                Else Begin
                                    Get _TestText     sLeftValue stFilter.iComp stFilter.stMatchEvalSequence stFilter.stRightValue.aOrList[iOrListIndex] to bFoundInList
                                End
                            End
                            Else If (iType=tqDATE) Begin
                                Get _TestDate     sLeftValue stFilter.iComp stFilter.stRightValue.aOrList[iOrListIndex] to bFoundInList
                            End
                            Else If (iType=tqDATETIME) Begin
                                Get _TestDateTime sLeftValue stFilter.iComp stFilter.stRightValue.aOrList[iOrListIndex] to bFoundInList
                            End
                        End
                    Loop
                    If (stFilter.iComp=tqNE) Begin // not-in-list
                        Move (not(bFoundInList)) to bEval
                    End
                    Else Begin // in-list 
                        Move bFoundInList to bEval
                    End
                End
                Else Begin
                    If (stFilter.stRightValue.iTable<>0 and not(_IsTableFixed(Self,stQ,stFilter.stRightValue.iTable))) Begin
                        Get _ValueSourceValue (&stQ) stFilter.stRightValue to sRightValue
                        If (stFilter.iComp=tqMATCH or stFilter.iComp=tqUCMATCH) Begin
                            If (stFilter.iComp=tqUCMATCH) Begin
                                Move (Uppercase(sRightValue)) to sRightValue
                            End
                            Get WildCardEvalSequence of oStringFunctions sRightValue to stFilter.stMatchEvalSequence
                        End
                    end
                    Else Begin
                        Move stFilter.stRightValue._sValue to sRightValue
                    End
                    If (iType=tqSTRING) Begin
                        If (stFilter.bUppercaseFilter) Begin
                            Get _TestString (Uppercase(sLeftValue)) stFilter.iComp stFilter.stMatchEvalSequence (Uppercase(sRightValue)) to bEval
                        End
                        Else Begin
                            Get _TestString   sLeftValue stFilter.iComp stFilter.stMatchEvalSequence sRightValue to bEval
                        End
                    End
                    Else If (iType=tqNUMBER) Begin
                        Get _TestNumber   sLeftValue stFilter.iComp sRightValue to bEval
                    End
                    Else If (iType=tqTEXT) Begin
                        If (stFilter.bUppercaseFilter) Begin
                            Get _TestText (Uppercase(sLeftValue)) stFilter.iComp stFilter.stMatchEvalSequence (Uppercase(sRightValue)) to bEval                            
                        End
                        Else Begin
                            Get _TestText     sLeftValue stFilter.iComp stFilter.stMatchEvalSequence sRightValue to bEval                            
                        End
                    End
                    Else If (iType=tqDATE) Begin
                        Get _TestDate     sLeftValue stFilter.iComp sRightValue to bEval
                    End
                    Else If (iType=tqDATETIME) Begin
                        Get _TestDateTime sLeftValue stFilter.iComp sRightValue to bEval
                    End
                End
                Function_Return bEval
            End_Function
            
        Function _EvaluateConstraints tTableQuery ByRef stQ tTQFilterSegment[] aFilters Boolean bListCheckAll Integer ByRef iFailedConstrainIndex Returns Boolean
            Integer iMax iIndex 
            Boolean bEval 
            Move (SizeOfArray(aFilters)-1) to iMax
            
            For iIndex from 0 to iMax
                Get _EvaluateFilter (&stQ) aFilters[iIndex] bListCheckAll to bEval
                If (not(bEval)) Begin
                    Move iIndex to iFailedConstrainIndex
                    Function_Return False
                End
            Loop

            Move -1 to iFailedConstrainIndex // Nothing failed
            Function_Return True
        End_Function
    
    //> The function returns true if the record currently in
    //> the buffer of the query main table evaluates true
    //> against the filters of stQ.
    Function Belongs tTableQuery stQ Returns Boolean
        Boolean bBelongs
        Integer iGrb
        // New record! Indicate that related buffers have to be reconsidered 
        // and found if needed:
        Send _TableRelateStatesReset (&stQ)
        // Evaluate against all filters added to the query:
        Get _EvaluateConstraints (&stQ) stQ.aFilters True (&iGrb) to bBelongs
        Function_Return bBelongs
    End_Function

//    Procedure ExecuteQuery tTableQuery ByRef stQ
//        Boolean bFound
//        Move True to stQ.bForcePrefetch
//        If (_CompileQuery(Self,&stQ)) Begin
//            If (_InitializeQuery(Self,&stQ)) Begin
//                // When bForcePrefetch is true finding the record will populate the
//                // result array inside stQ:
//                Get FindRecord (&stQ) to bFound // and that's all we need
//                Get SystemTimeMilliSeconds of oDateFunctions to stQ._stControlBlock.stStopTime
//            End
//        End
//    End_Procedure

    Procedure PurgeResultSet tTableQuery ByRef stQ
        Move stQ.iTable to stQ.stResultSet.iTable
        Move (ResizeArray(stQ.stResultSet.aRecords,0)) to stQ.stResultSet.aRecords
        Move -1 to stQ.stResultSet._iCurrentRowPointer
    End_Procedure
    
    Function _OrderingSegmentSortValue tTableQuery ByRef stQ tTQOrderBySegment stOrderingSegment Returns String
        Integer iTable iColumn 
        String sValue 
        
        Move stOrderingSegment.stValueSource.iTable to iTable
        
        If (iTable<>0) Begin // a table column value
            Move stOrderingSegment.stValueSource.iColumn to iColumn
            If (iTable<>stQ.iTable) Begin // It's a "parent" table
                Send _RelateToTable (&stQ) iTable
            End
            Get_Field_Value iTable iColumn to sValue
            Move (Rtrim(sValue)) to sValue
        End
        If (iTable=0 and SizeOfArray(stOrderingSegment.stValueSource.aSymbols)>0) Begin 
            // It's an expression
            Get _ValueSourceValue (&stQ) stOrderingSegment.stValueSource to sValue
//            Get ValueTypeTQtoDF stOrderingSegment.stValueSource.iType to iDFType
//            Get SortValueFormat of oIndexFunctions sValue iDFType stOrderingSegment.stValueSource.iLen stOrderingSegment.stValueSource.iDecimals to sValue
        End
        Function_Return sValue
    End_Function

    //> This is a helper function that converts a DF value type to
    //> a TQ value type. (i.e. DF_DATE -> tqDATE)
    Function ValueTypeTQtoDF Integer iTQType Returns Integer
        Integer iDFType
        Move DF_ASCII to iDFType // Default return value
        If (iTQType=tqSTRING) Begin
            Move DF_ASCII to iDFType
        End
        Else If (iTQType=tqNUMBER) Begin
            Move DF_BCD to iDFType
        End
        Else If (iTQType=tqTEXT) Begin
            Move DF_TEXT to iDFType
        End
        Else If (iTQType=tqDATE) Begin
            Move DF_DATE to iDFType
        End
        Else If (iTQType=tqDATETIME) Begin
            Move DF_DATETIME to iDFType
        End
        Function_Return iDFType
    End_Function

    //> This is a helper function that converts a TQ value type to
    //> a DF value type. (i.e. tqNUMBER -> DF_BCD)
    Function ValueTypeDFtoTQ Integer iDFType Returns Integer
        Integer iTQType
        Move tqSTRING to iTQType // Default return type
        If (iDFType=DF_ASCII) Begin
            Move tqSTRING to iTQType
        End
        Else If (iDFType=DF_BCD) Begin
            Move tqNUMBER to iTQType
        End
        Else If (iDFType=DF_TEXT) Begin
            Move tqTEXT to iTQType
        End
        Else If (iDFType=DF_DATE) Begin
            Move tqDATE to iTQType
        End
        Else If (iDFType=DF_DATETIME) Begin
            Move tqDATETIME to iTQType
        End
        Function_Return iTQType
    End_Function


                Procedure _ResultSetAddCurrentRecord tTableQuery ByRef stQ
                    Integer iRow iSegment iMax iColumn
                    Integer iTable
                    String sValue // sSortValue

                    // Row ID:
                    Move (SizeOfArray(stQ.stResultSet.aRecords)) to iRow
                    Move (GetRowID(stQ.iTable)) to stQ.stResultSet.aRecords[iRow].riRowId

                    // Calculate sort value:
//                    Move "" to sSortValue
                    Move (ResizeArray(stQ.stResultSet.aRecords[iRow].aSortColumnValues,0)) to stQ.stResultSet.aRecords[iRow].aSortColumnValues
                    Move (SizeOfArray(stQ.aOrdering)-1) to iMax
                    For iSegment from 0 to iMax
                        Get _OrderingSegmentSortValue (&stQ) stQ.aOrdering[iSegment] to sValue
                        Move sValue to stQ.stResultSet.aRecords[iRow].aSortColumnValues[iSegment]
                    Loop
//                    Move sSortValue to stQ.stResultSet.aRecords[iRow].sSortValue

                    // Read column values:
                    Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
                    For iColumn from 0 to iMax
                        Get _ValueSourceValue (&stQ) stQ.aColumnSources[iColumn] to stQ.stResultSet.aRecords[iRow].aColumnValues[iColumn]
                    Loop
                End_Procedure
                
                    Function _ResultSetRecordsCompare tTQResultRow stVal1 tTQResultRow stVal2 Returns Integer
                        Integer iSegmentMax iSegment iComp
                        tTQOrderBySegment[] aOrdering
                        Get _paOrderingTmp to aOrdering
                        
                        Move (SizeOfArray(aOrdering)-1) to iSegmentMax
                        For iSegment from 0 to iSegmentMax
                            Get _SQLCheckAgainstParentRecord_CompareSortingSegmentValues stVal1.aSortColumnValues[iSegment] stVal2.aSortColumnValues[iSegment] aOrdering[iSegment].stValueSource.iType to iComp
                            If (aOrdering[iSegment].bDescending) Begin
                                If (iComp=tqLT) Begin
                                    Move (tqGT) to iComp
                                End
                                Else If (iComp=tqGT) Begin
                                    Move (tqLT) to iComp
                                End
                            End
                            If (iComp<>tqEQ) Begin
                                If (iComp=tqLT) Begin
                                    Function_Return (LT)
                                End
                                Else Begin
                                    Function_Return (GT)
                                End
                            End
                        Loop
                        
                        Function_Return (EQ)
                    End_Function
                    

                Procedure _ResultSetSort tTableQuery ByRef stQ
                    If (SizeOfArray(stQ.aOrdering)>0) Begin
                        Set _paOrderingTmp to stQ.aOrdering
                        Move (SortArray(stQ.stResultSet.aRecords,Self,GET__ResultSetRecordsCompare)) to stQ.stResultSet.aRecords
                    End
                End_Procedure

                Procedure _ResultSetActivateCurrentRecord tTableQuery ByRef stQ
                    Boolean bFound
                    Integer iTable
                    RowID riRowID
                    Move stQ.iTable to iTable
                    Move stQ.stResultSet.aRecords[stQ.stResultSet._iCurrentRowPointer].riRowId to riRowID
                    Move (FindByRowID(iTable,riRowID)) to bFound
                    Send _TableRelateStatesReset (&stQ)
                    If (bFound) Begin
                        Send _RelateMainRecord (&stQ)
                    End
                    Else Begin
                        Send OnError 725 "Result set record not found"
                    End
                End_Procedure

            Function _FindFirstRecordAux tTableQuery ByRef stQ Integer ByRef iFailedConstrainIndex Returns Boolean
                Boolean bFound bEval
                Integer iTable iIndex iJunk

                Move stQ.iTable to iTable
                Move stQ._stCompiled.iIndex to iIndex
                Clear iTable

                Send _TableRelateStatesReset (&stQ) // Reset information about what related records have already been found
                Send _SeedRecordBuffer stQ

                If (stQ._stCompiled.bBackwards) Begin
                    Vfind iTable iIndex LE
                End
                Else Begin
                    Vfind iTable iIndex GE
                    If (Found) Begin // Problem and fix pointed out by Russell McDougall
                        // From the on-line help:

                        // "A Find GE always finds a record unless the table is empty. A find GE after
                        // the last record in the table will still return the last record. It always sets
                        // the Predefined Indicators Found to True and FindErr to False. Note that this
                        // behavior is different than for LE. A Find LE before the first record in the table
                        // will not return a record, and will set the predefined indicators Found to False
                        // and FindErr to True."

                        // This feature of the find and vfind commands forces us to check
                        // that the record found is not a record that it really shouldn't have found in the
                        // first place:

                        Get _EvaluateConstraints (&stQ) stQ._stCompiled.aJumpInValues False (&iFailedConstrainIndex) to bEval
                        If (not(bEval)) Begin
                            // At this point iFailedConstrainIndex does not have a meaningful value because the
                            // the find result is irradical.
                            // 
                            // In this case iFailedConstrainIndex must be pointed to the least significant tqEQ 
                            // segment of the JumpOutValues.
                            Move (SizeOfArray(stQ._stCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
                            While (iFailedConstrainIndex>=0 and stQ._stCompiled.aJumpOutValues[iFailedConstrainIndex].iComp<>tqEQ)
                                Decrement iFailedConstrainIndex
                            Loop
                        End
                        Move bEval to Found
                    End
                End
                Move (Found) to bFound

                Increment stQ._stControlBlock.iFindCount
                If (bFound) Begin
                    Repeat
                        // Jump out?
                        Get _EvaluateConstraints (&stQ) stQ._stCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
                            Function_Return False
                        End
                        // Evaluate 'other' criteria
                        Get _EvaluateConstraints (&stQ) stQ._stCompiled.aOtherConditions True (&iJunk) to bEval
                        If (not(bEval)) Begin
                            If (stQ._stCompiled.bBackwards) Begin
                                Vfind iTable iIndex LT
                            End
                            Else Begin
                                Vfind iTable iIndex GT
                            End
                            Move (Found) to bFound
                            Increment stQ._stControlBlock.iFindCount
                            Send _TableRelateStatesReset (&stQ)
                            If (not(bFound)) Begin // end of table
                                Move (SizeOfArray(stQ._stCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
                                Function_Return False
                            End
                        End
                    Until (bEval)
                End

                If (bFound) Begin
                    Increment stQ._stControlBlock.iSelectCount
                End
                Function_Return bFound
            End_Function // _FindFirstRecordAux

            Procedure _SQLBindResultTables tTableQuery ByRef stQ
                Integer iItem iItemMax iTable
                Move (SizeOfArray(stQ.aColumnSources)-1) to iItemMax

                If (iItemMax>=0) Begin
                    For iItem from 0 to iItemMax
                        If (stQ.aColumnSources[iItem].iTable>0 and stQ.aColumnSources[iItem].iColumn=0) Begin
                            Move stQ.aColumnSources[iItem].iTable to iTable
                            Send SQLBindFile of stQ._stControlBlock.stSQLStatementHandle.hStatHandle iTable
                        End
                    Loop
                End
                Else Begin
                    Send SQLBindFile of stQ._stControlBlock.stSQLStatementHandle.hStatHandle stQ.iTable
                End
            End_Procedure

                    Function _SQLCheckAgainstParentRecord_CompareSortingSegmentValues String sValue1 String sValue2 Integer iType Returns Integer
                        Date dValue1 dValue2
                        DateTime dtValue1 dtValue2
                        Number nValue1 nValue2
                        If (iType=tqNUMBER) Begin
                            Move sValue1 to nValue1
                            Move sValue2 to nValue2
                            If (nValue1>nValue2) Begin
                                Function_Return tqGT
                            End
                            If (nValue1<nValue2) Begin
                                Function_Return tqLT
                            End
                        End
                        Else If (iType=tqDATE) Begin
                            Move sValue1 to dValue1
                            Move sValue2 to dValue2
                            If (dValue1>dValue2) Begin
                                Function_Return tqGT
                            End
                            If (dValue1<dValue2) Begin
                                Function_Return tqLT
                            End
                        End
                        Else If (iType=tqDATETIME) Begin
                            Move sValue1 to dtValue1
                            Move sValue2 to dtValue2
                            If (dtValue1>dtValue2) Begin
                                Function_Return tqGT
                            End
                            If (dtValue1<dtValue2) Begin
                                Function_Return tqLT
                            End
                        End
                        Else If (iType=tqSTRING) Begin
                            If (sValue1>sValue2) Begin
                                Function_Return tqGT
                            End
                            If (sValue1<sValue2) Begin
                                Function_Return tqLT
                            End
                        End
                        Else Begin
                            Send OnError 726 ("Unknown column type ("+String(iType))
                        End
                        Function_Return tqEQ
                    End_Function
            
                Function _SQLCheckAgainstParentRecord tTableQuery ByRef stQ Boolean ByRef bCatchUpWithParent Returns Boolean
                    Integer iItem iItemMax iCompareResult
                    String sValue1 sValue2
                    Move (SizeOfArray(stQ._stControlBlock.stInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
                    For iItem from 0 to iItemMax
                        Move stQ._stControlBlock.stInnerJoinCB.aCurrentParentSortValues[iItem] to sValue1
                        Get ResultColumnValue (&stQ) stQ.aOrdering[iItem].stValueSource.iTable stQ.aOrdering[iItem].stValueSource.iColumn to sValue2
                        If (stQ.aOrdering[iItem].bUppercase=1) Begin // -1:don't care, 0:no, 1:yes
                           // Move (Uppercase(sValue1)) to sValue1 // This has already been uppercased by the parent record collection mechanism (procedure _ReadParentSortValues)
                            Move (Uppercase(sValue2)) to sValue2
                        End
                        Get _SQLCheckAgainstParentRecord_CompareSortingSegmentValues sValue1 sValue2 stQ.aOrdering[iItem].stValueSource.iType to iCompareResult
                        If (stQ.aOrdering[iItem].bDescending) Begin
                            Move (If(iCompareResult=tqGT,tqLT,tqGT)) to iCompareResult
                        End
                        If (iCompareResult=tqGT) Begin // Parent is greater => child query must catch up
                            Move True to bCatchUpWithParent
                            Function_Return False
                        End
                        Else If (iCompareResult=tqLT) Begin // Child is greater which means we must fake a end-of-result set
                            Move False to bCatchUpWithParent
                            Function_Return False
                        End
                    Loop
                    Move False to bCatchUpWithParent
                    Function_Return True
                End_Function
                
            Function _SQLFindNextRecord tTableQuery ByRef stQ Returns Boolean
                Integer iFetchResult iItem iItemMax
                Boolean bFound bSelect bInnerJoin bCatchUpWithParent bBelongsToCurrentParent

                Move (SizeOfArray(stQ._stControlBlock.stInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
                Move (iItemMax>=0) to bInnerJoin // We are an inner join and should be prepared to fake a 'record not found'

                If (bInnerJoin) Begin

                    If (stQ._stControlBlock.stInnerJoinCB.bEndOfResultSet) Begin
                        Function_Return False
                    End

                    Repeat
                        If (stQ._stControlBlock.stInnerJoinCB.bSkipNextFetch) Begin
                            Move False to stQ._stControlBlock.stInnerJoinCB.bSkipNextFetch
                            Move True to bFound
                        End
                        Else Begin
                            Get SQLFetch of stQ._stControlBlock.stSQLStatementHandle.hStatHandle to iFetchResult
                            Move (iFetchResult<>0) to bFound
                            If (bFound) Begin
                                Send _SQLBindResultTables (&stQ)
                                Increment stQ._stControlBlock.iSelectCount
                            End
                            Increment stQ._stControlBlock.iFindCount
                        End
                        If (bFound) Begin
                            Send _TableRelateStatesReset (&stQ)
                            Send _SQLBindResultTables (&stQ)
                            Get _SQLCheckAgainstParentRecord (&stQ) (&bCatchUpWithParent) to bBelongsToCurrentParent
                            If (bBelongsToCurrentParent) Begin
                                Move True to bSelect
                            End
                            Else Begin
                                If (not(bCatchUpWithParent)) Begin
                                    Move True to stQ._stControlBlock.stInnerJoinCB.bSkipNextFetch
                                End
                            End
                        End
                        Else Begin
                            Move True to stQ._stControlBlock.stInnerJoinCB.bEndOfResultSet
                        End
                    Until (not(bFound) or bSelect or not(bCatchUpWithParent))

                    If (bSelect) Begin
                        Increment stQ._stControlBlock.iSelectCount
                        Function_Return True
                    End

                End
                Else Begin

                    Get SQLFetch of stQ._stControlBlock.stSQLStatementHandle.hStatHandle to iFetchResult
                    Move (iFetchResult<>0) to bFound
                    If (bFound) Begin
                        Send _SQLBindResultTables (&stQ)
                        Increment stQ._stControlBlock.iSelectCount
                    End
                    Increment stQ._stControlBlock.iFindCount

                    Function_Return bFound
                End
                Function_Return False
            End_Function

        Register_Function FindRecord tTableQuery ByRef stQ Returns Boolean

        Function _FindFirstRecord tTableQuery ByRef stQ Returns Boolean  // Todo: initialiser bIncremented og iFailedConstrainIndex
            Boolean bFound bIncremented bTmp bOriginalBreakLevelTest
            Integer iLastIndex iSize iTable
            Integer iFailedConstrainIndex
            Integer iLogState iFetchResult

            Move 0 to stQ._stControlBlock.iFindCount
            Move 0 to stQ._stControlBlock.iSelectCount
            Move False to stQ._stControlBlock.bBreakScan
            Send PurgeResultSet (&stQ) // Zero the result set


            If (stQ._stControlBlock.iQueryMethod=tqSQLPKG) Begin
                Get _SQLFindNextRecord (&stQ) to bFound
            End
            Else Begin

                
                // Makes the procedure reset all OrList pointers. Return value not used:
                Get _IncrementJumpInOutConditions (&stQ) -1 to bFound
                Move 0 to iFailedConstrainIndex
                
                Move stQ.iTable to iTable
                Clear iTable //
                Send _TableRelateStatesReset (&stQ)
                Send _AssignConstraintValues (&stQ) (&stQ._stCompiled.aJumpInValues)
                Send _AssignConstraintValues (&stQ) (&stQ._stCompiled.aJumpOutValues)
                Send _AssignConstraintValues (&stQ) (&stQ._stCompiled.aOtherConditions)

                If (stQ._stCompiled.bPrefetch) Begin
                    Move False to stQ._stCompiled.bPrefetch // Temporarily set bPrefetch to false

                    Send ReUse (&stQ) // resets stQ.blabla.bInitialized
                    Move stQ.bForcePrefetch to bTmp

                    // Here comes a dirty trick to avoid FindRecord deleting
                    // the ResultArray of the stQ variable on completion. The
                    // default behavior is to reset the resultset on completion if
                    // prefetch was not forced. It's dirty because FindRecord is 
                    // fooled into not re-compiling the report. Here it goes:
                    Move True to stQ.bForcePrefetch
                    Move _giTQLogState to iLogState
                    Move 0 to _giTQLogState // Do not log the "inner" loop

                    Move stQ.bBreakLevelTest to bOriginalBreakLevelTest
                    
                    While (FindRecord(Self,&stQ))
                        Send _ResultSetAddCurrentRecord (&stQ)
                    Loop
                    
                    Move bOriginalBreakLevelTest to stQ.bBreakLevelTest
                    Move bTmp to stQ.bForcePrefetch
                    Move iLogState to _giTQLogState // Restore log-state

                    Send _ResultSetSort (&stQ)

                    Move False to stQ._stControlBlock.bBreakScan // Cancel effect of possible break imposed by limit
                    Move True to stQ._stCompiled.bPrefetch // Restore bPrefetch
                    If (stQ._stCompiled._iPushLimit<>0) Begin

                        If (SizeOfArray(stQ.stResultSet.aRecords)>Abs(stQ._stCompiled._iPushLimit)) Begin
                            // If the record set is greater than our limit we'll have to prune it.
                            If (stQ.iLimit>0) Begin // We're supposed to return the head
                                Move (ResizeArray(stQ.stResultSet.aRecords,stQ._stCompiled._iPushLimit)) to stQ.stResultSet.aRecords
                            End
                            Else Begin // We're supposed to take the tail
                                Move (SizeOfArray(stQ.stResultSet.aRecords)-1) to iLastIndex
                                Move stQ._stCompiled._iPushLimit to iSize
                                Move (CopyArray(stQ.stResultSet.aRecords,iLastIndex-iSize+1,iLastIndex)) to stQ.stResultSet.aRecords
                            End
                            Move (SizeOfArray(stQ.stResultSet.aRecords)) to stQ._stControlBlock.iSelectCount
                        End

                        If (SizeOfArray(stQ.stResultSet.aRecords)>stQ._stCompiled._iPushLimit) Begin
                            Move (ResizeArray(stQ.stResultSet.aRecords,stQ._stCompiled._iPushLimit)) to stQ.stResultSet.aRecords
                            Move (SizeOfArray(stQ.stResultSet.aRecords)) to stQ._stControlBlock.iSelectCount
                        End
                        Move stQ._stCompiled._iPushLimit to stQ._stCompiled._iLimit
                        Move 0 to stQ._stCompiled._iPushLimit
                    End
                    Move (SizeOfArray(stQ.stResultSet.aRecords)>0) to bFound
                    If (bFound) Begin
                        Move 0 to stQ.stResultSet._iCurrentRowPointer
                        Send _ResultSetActivateCurrentRecord (&stQ)
                    End
                End
                Else Begin
                    // Finding the first record has been implemented as a loop because it may involve
                    // a number of attempts (potentially one for each combination of or-list values).
                    Repeat
                        Get _FindFirstRecordAux (&stQ) (&iFailedConstrainIndex) to bFound
                        If (not(bFound)) Begin
                            Get _IncrementJumpInOutConditions (&stQ) iFailedConstrainIndex to bIncremented
                            If (bIncremented) Begin
                                Send _ReassignJumpInOutConstraintValues (&stQ) (&stQ._stCompiled.aJumpInValues) (&stQ._stCompiled.aJumpOutValues)
                            End
                        End
                    Until (bFound or not(bIncremented))
                End
            End

            Function_Return bFound
        End_Function // _FindFirstRecord

            Function _FindNextRecordAux tTableQuery ByRef stQ Integer ByRef iFailedConstrainIndex Returns Boolean
                Integer iTable iIndex iJunk
                Boolean bFound bEval

                Move stQ.iTable to iTable
                Move stQ._stCompiled.iIndex to iIndex
                If (stQ._stCompiled.bBackwards) Begin
                    Vfind iTable iIndex LT
                End
                Else Begin
                    Vfind iTable iIndex GT
                End
                Move (Found) to bFound
                Increment stQ._stControlBlock.iFindCount
                Send _TableRelateStatesReset (&stQ)
                If (bFound) Begin
                    Repeat
                        // Jump out?
                        Get _EvaluateConstraints (&stQ) stQ._stCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
                            Function_Return False
                        End
                        // Evaluate 'other' criteria
                        Get _EvaluateConstraints (&stQ) stQ._stCompiled.aOtherConditions True (&iJunk) to bEval
                        If (not(bEval)) Begin
                            If (stQ._stCompiled.bBackwards) Begin
                                Vfind iTable iIndex LT
                            End
                            Else Begin
                                Vfind iTable iIndex GT
                            End
                            Increment stQ._stControlBlock.iFindCount
                            Move (Found) to bFound
                            Send _TableRelateStatesReset (&stQ)
                            If (not(bFound)) Begin // end of table
                                Move (SizeOfArray(stQ._stCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
                                Function_Return False
                            End
                        End
                    Until (bEval)
                End

                If (bFound) Begin
                    Increment stQ._stControlBlock.iSelectCount
                End

                Function_Return bFound
            End_Function

        Function _FindNextRecord tTableQuery ByRef stQ Returns Boolean
            Boolean bFound bIncremented
            Integer iFailedConstrainIndex iFetchResult

            If (stQ._stControlBlock.bBreakScan) Begin
                Move False to bFound
            End
            Else Begin

                If (stQ._stControlBlock.iQueryMethod=tqSQLPKG) Begin
                    Get _SQLFindNextRecord (&stQ) to bFound
                End
                Else Begin
                    If (stQ._stCompiled.bPrefetch) Begin
                        Move ((stQ.stResultSet._iCurrentRowPointer+1)<SizeOfArray(stQ.stResultSet.aRecords)) to bFound
                        If (bFound) Begin
                            Increment stQ.stResultSet._iCurrentRowPointer
                            Send _ResultSetActivateCurrentRecord (&stQ)
                        End
                    End
                    Else Begin
                        Move 0 to iFailedConstrainIndex
                        Get _FindNextRecordAux (&stQ) (&iFailedConstrainIndex) to bFound

                        Repeat
                            If (not(bFound)) Begin
                                Get _IncrementJumpInOutConditions (&stQ) iFailedConstrainIndex to bIncremented
                                If (bIncremented) Begin
                                    Send _ReassignJumpInOutConstraintValues (&stQ) (&stQ._stCompiled.aJumpInValues) (&stQ._stCompiled.aJumpOutValues)
                                    Get _FindFirstRecordAux (&stQ) (&iFailedConstrainIndex) to bFound
                                End
                            End
                        Until (bFound or not(bIncremented))
                    End
                End
            End

            Function_Return bFound
        End_Function

// *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions ***

        Function _ColumnSourceFind tTableQuery stQ Integer iTable Integer iColumn Returns Integer
            Integer iItem iMax
            Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
            For iItem from 0 to iMax
                If (stQ.aColumnSources[iItem].iTable=iTable) Begin
                    If (stQ.aColumnSources[iItem].iColumn=iColumn or stQ.aColumnSources[iItem].iColumn=0) Begin
                        Function_Return iItem
                    End
                End
            Loop
            Function_Return -1 // not found
        End_Function

        // Internal function used to find the index for the relation recipé for tabel iTable.
        Function _FindTableRelation tTableQuery stQ Integer iTable Returns Integer
            Integer iItem iMax
            Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
            For iItem from 0 to iMax
                If (stQ.aTableRelations[iItem].iTargetTable=iTable) Begin
                    Function_Return iItem
                End
            Loop
            Function_Return -1 // not found
        End_Function

        // If bFixed is true it means that the parent record is fixed for the duration of the query. In turn, that means
        // that the relation mechanism will not find records in that table (iTargetTable).
        Procedure _AddTableRelation tTableQuery ByRef stQ Integer iTargetTable Boolean bFixed
            Integer iItem
            Get _FindTableRelation stQ iTargetTable to iItem
            If (iItem=-1) Begin
                Move (SizeOfArray(stQ.aTableRelations)) to iItem
                Move iTargetTable to stQ.aTableRelations[iItem].iTargetTable
                Move -1 to stQ.aTableRelations[iItem]._iEmbeddedIndex
                Move bFixed to stQ.aTableRelations[iItem].bFixed
            End
            Else Begin
                If (bFixed) Begin // If it's already there then bFixed=true wins.
                    Move bFixed to stQ.aTableRelations[iItem].bFixed
                End
            End
        End_Procedure

            Function _CompareTableRelationSegments _tTQTableRelationSegment strValue1 _tTQTableRelationSegment strValue2 Returns Integer
                Number nValue1 nValue2
                Move (strValue1.iInnerJoinComp*10000+strValue1.iSourceColumn*10000+strValue1.iSourceTable*10000+strValue1.iTargetColumn) to nValue1
                Move (strValue2.iInnerJoinComp*10000+strValue2.iSourceColumn*10000+strValue2.iSourceTable*10000+strValue2.iTargetColumn) to nValue2
                If (nValue1<nValue2) Begin
                    Function_Return (LT)
                End
                Else If (nValue1>nValue2) Begin
                    Function_Return (GT)
                End
                Function_Return (EQ)
            End_Function

        Function _TableRelationsAreSegmentArraysIdentical _tTQTableRelationSegment[] aSegments1 _tTQTableRelationSegment[] aSegments2 Returns Boolean
            Integer iItem iItemMax1 iItemMax2
            Move (SizeOfArray(aSegments1)-1) to iItemMax1
            Move (SizeOfArray(aSegments2)-1) to iItemMax2
            If (iItemMax1<>iItemMax2) Begin
                Function_Return False
            End
            // The arrays are not ordered so to tell if they are identical they need to be sorted first.
            Move (SortArray(aSegments1,Self,GET__CompareTableRelationSegments)) to aSegments1
            Move (SortArray(aSegments2,Self,GET__CompareTableRelationSegments)) to aSegments2
            For iItem from 0 to iItemMax1
                If (_CompareTableRelationSegments(Self,aSegments1[iItem],aSegments2[iItem])<>EQ) Begin
                    Function_Return False
                End
            Loop
        End_Function

        Function _TableRelationsAreIdentical tTQTableRelation strRel1 tTQTableRelation strRel2 Returns Boolean
            If (strRel1.iTargetTable<>strRel2.iTargetTable or strRel1.bFixed<>strRel2.bFixed) Begin
                Function_Return False
            End
            If (not(_TableRelationsAreSegmentArraysIdentical(Self,strRel1.aSegments,strRel2.aSegments))) Begin
                Function_Return False
            End
            Function_Return True
        End_Function

        Function _AddTableRelationB2B tTableQuery ByRef stQ tTQTableRelation strRelation Returns Boolean
            Integer iItem
            Get _FindTableRelation stQ strRelation.iTargetTable to iItem
            If (iItem=-1) Begin
                Move strRelation to stQ.aTableRelations[SizeOfArray(stQ.aTableRelations)]
            End
            Else Begin
                If (not(_TableRelationsAreIdentical(Self,strRelation,stQ.aTableRelations[iItem]))) Begin
                    Send OnError 727 "Table takes on more than one role"
                    Function_Return False
                End
            End
            Function_Return True
        End_Function

    Procedure AddTableRelation tTableQuery ByRef stQ Integer iTargetTable
        Send _AddTableRelation (&stQ) iTargetTable False
    End_Procedure

    // This is called from the AddFilterRelate procedure.
    Procedure AddTableRelationFixedRecord tTableQuery ByRef stQ Integer iTargetTable
        Send _AddTableRelation (&stQ) iTargetTable True
    End_Procedure

    Procedure _AddTableRelationSegment tTableQuery ByRef stQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
        Integer iItem
        tTQTableRelation strRelatation
        _tTQTableRelationSegment stSegment
        Get _FindTableRelation stQ iTargetTable to iItem
        If (iItem>=0) Begin

            // Check that iSourceTable is already available in the .aRelations member. If not: error!
            If (iSourceTable=stQ.iTable or _FindTableRelation(Self,stQ,iSourceTable)<>-1) Begin
                Move stQ.aTableRelations[iItem] to strRelatation
                Move iSourceTable to stSegment.iSourceTable
                Move iComp to stSegment.iInnerJoinComp
                Move iSourceColumn to stSegment.iSourceColumn
                Move iTargetColumn to stSegment.iTargetColumn
                Move stSegment to strRelatation.aSegments[SizeOfArray(strRelatation.aSegments)]
                Move strRelatation to stQ.aTableRelations[iItem]
            End
            Else Begin
                Send OnError 728 ("No relation has been set up for table "+String(iSourceTable))
            End
        End
        Else Begin
            Send OnError 729 ("No relation has been set up for table "+String(iTargetTable))
        End
    End_Procedure

    Procedure AddTableRelationSegment tTableQuery ByRef stQ Integer iSourceTable Integer iSourceColumn Integer iTargetTable Integer iTargetColumn
        Send _AddTableRelationSegment (&stQ) iSourceTable iSourceColumn tqEQ iTargetTable iTargetColumn
    End_Procedure

    Procedure _AddTableRelationInnerJoinSegment tTableQuery ByRef stQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
        Send _AddTableRelationSegment (&stQ) iSourceTable iSourceColumn iComp iTargetTable iTargetColumn
    End_Procedure

    // Use this method over the AddTableRelation ditto to register a table relation by its generic relation
    Procedure _AddTableRelationAuto tTableQuery ByRef stQ Integer iSourceTable Integer iTargetTable Boolean bFixed
        Integer iItem iMax iRelateItem
        Integer[] aSourceColumns aTargetColumns

        Get _FindTableRelation stQ iTargetTable to iRelateItem
        If (iRelateItem=-1) Begin
            If (TableColumnsRelatingBetweenTables(oOverlapColumnFunctions,iSourceTable,iTargetTable,&aSourceColumns,&aTargetColumns)) Begin
                Send _AddTableRelation (&stQ) iTargetTable bFixed
                Move (SizeOfArray(aSourceColumns)-1) to iMax
                For iItem from 0 to iMax
                    Send AddTableRelationSegment (&stQ) iSourceTable aSourceColumns[iItem] iTargetTable aTargetColumns[iItem]
                Loop
            End
            Else Begin
                Send OnError 730 ("Tables do not relate ("+String(iSourceTable)+"->"+String(iTargetTable)+")")
            End
        End
        Else Begin // If a relation is already there:
// ToDo:    // Here we need to check if the current segment array is empty.
            // If it is, we add the relation segments
            // If it's not, we should check that it is currently set
            // to the "plain df relation" and give an Error if it's not.
        End
    End_Procedure

    Procedure AddTableRelationAuto tTableQuery ByRef stQ Integer iSourceTable Integer iTargetTable
        Send _AddTableRelationAuto (&stQ) iSourceTable iTargetTable False
    End_Procedure

    Procedure AddTableRelationAutoFixed tTableQuery ByRef stQ Integer iSourceTable Integer iTargetTable
        Send _AddTableRelationAuto (&stQ) iSourceTable iTargetTable True
    End_Procedure

        Function _TableRelationAlreadyOK tTableQuery ByRef stQ tTQTableRelation strRelation Returns Boolean
            Integer iSegment iSegmentMax
            String sSourceValue sTargetValue

            If (not(strRelation.bFixed)) Begin
                Move (SizeOfArray(strRelation.aSegments)-1) to iSegmentMax
                For iSegment from 0 to iSegmentMax
                    Get ResultColumnValue (&stQ) strRelation.aSegments[iSegment].iSourceTable strRelation.aSegments[iSegment].iSourceColumn to sSourceValue
                    Get_Field_Value strRelation.iTargetTable strRelation.aSegments[iSegment].iTargetColumn to sTargetValue
                    If (sSourceValue<>sTargetValue) Begin
                        Function_Return (False)
                    End
                Loop
            End
            Function_Return (True)
        End_Function

        Function _SQLNumericToDFNumeric Integer iTable String sValue Returns String
            Integer iDriverDS iRuntimeDS iDriverIndex
            String sDriver

            Get_Attribute DF_FILE_DRIVER of iTable to sDriver
            Get DriverIndex of oTableDriverFunctions sDriver to iDriverIndex
            Get_Attribute DF_DRIVER_DRIVER_DECIMAL_SEPARATOR of iDriverIndex to iDriverDS

            Get_Attribute DF_DECIMAL_SEPARATOR to iRuntimeDS

            If (iRuntimeDS<>iDriverDS) Begin
                Move (Replaces(Character(iDriverDS),sValue,Character(iRuntimeDS))) to sValue
            End

            If (Left(sValue,1)=Character(iRuntimeDS)) Begin
                Move ("0"+sValue) to sValue
            End

            Function_Return sValue
        End_Function

        Function __FindColumnSourceIndex tTableQuery stQ String sExpr Returns Integer
            Integer iMax iItem
            Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
            For iItem from 0 to iMax
                If (sExpr=stQ.aColumnSources[iItem].sConstant) Begin
                    Function_Return iItem
                End
            Loop
            Function_Return -1
        End_Function

    //> This can be called with the same index as is used in a tDFQ3 variable? NO IT CAN'T
    Function OutputColumnValue tTableQuery ByRef stQ Integer iColumnIndex Returns String
        String sValue sExpr
        _tTQValueSource stSource
        Move stQ.aOutputColumns[iColumnIndex] to stSource
        If (stSource.iTable>0) Begin // Table column reference
            Get ResultColumnValue (&stQ) stSource.iTable stSource.iColumn to sValue
        End
        Else If (SizeOfArray(stSource.aSymbols)>0) Begin // Expression
            If (stQ._stControlBlock.iQueryMethod=tqDATAFLEX) Begin
                Get _ValueSourceValue (&stQ) stSource to sValue
                
            End
            Else Begin
                // Here we need to re-calculate iColumnIndex because that
                // is pointing to an output column, where as _SQLColumnValue
                // takes a result-column parameter.
                Move stSource.sConstant to sExpr // We are looking for this in the aColumnSourcesArray
                Get __FindColumnSourceIndex stQ sExpr to iColumnIndex
                If (iColumnIndex<>-1) Begin
                    Get _SQLColumnValue stQ iColumnIndex to sValue
                End
                Else Begin
                    Send OnError 754 "Output column not located in column sources."
                End
            End
        End
        Function_Return sValue
    End_Function
    
    Function _SQLColumnValue tTableQuery stQ Integer iResultColumn Returns String
        Integer iType
        String sValue
        Get SQLColumnValue of stQ._stControlBlock.stSQLStatementHandle.hStatHandle (iResultColumn+1) to sValue
        Move stQ.aColumnSources[iResultColumn].iType to iType
        If (iType=tqDATE) Begin
            Get SQLDateToDFDate of stQ._stControlBlock.stSQLStatementHandle.hStatHandle sValue to sValue
        End
        Else If (iType=tqNUMBER) Begin
            Get _SQLNumericToDFNumeric stQ.iTable sValue to sValue
        End
        Else If (iType=tqSTRING or iType=tqTEXT) Begin
            If (stQ._stControlBlock.bSQLTableIsAnsi) Begin
//                Move (ToOEM(sValue)) to sValue
            End
            Move (Rtrim(sValue)) to sValue
        End
        Function_Return sValue
    End_Function
    
    Function ResultColumnValue tTableQuery ByRef stQ Integer iTable Integer iColumn Returns String
        Integer iRelateItem iColumnSourceItem iType
        Integer iDriverDecimalPlaces iDecimalPlaces
        String sValue
        If (stQ._stControlBlock.iQueryMethod=tqDATAFLEX) Begin
            Send _RelateToTable (&stQ) iTable
            If (iColumn=0) Begin
                Move (SerializeRowID(GetRowID(iTable))) to sValue
            End
            Else Begin
                Get_Field_Value iTable iColumn to sValue
                Move (Rtrim(sValue)) to sValue
            End
        End
        Else Begin
            If (SizeOfArray(stQ.aColumnSources)=0) Begin
                If (iTable=stQ.iTable) Begin
                    Get_Field_Value iTable iColumn to sValue
                    Move (Rtrim(sValue)) to sValue
                End
                Else Begin
                    Send OnError 731 "Column not part of result set."
                End
            End
            Else Begin
                Get _ColumnSourceFind stQ iTable iColumn to iColumnSourceItem
                If (iColumnSourceItem<>-1) Begin
                    If (stQ.aColumnSources[iColumnSourceItem].iColumn=0) Begin
                        Get_Field_Value iTable iColumn to sValue
                        Move (Rtrim(sValue)) to sValue
                    End
                    Else Begin
                        Get _SQLColumnValue stQ iColumnSourceItem to sValue
                    End
                End
                Else Begin
                    Send OnError 732 "Unknown result column"
                End
            End
        End
        Function_Return sValue
    End_Function

    Function ResultColumnValues tTableQuery ByRef stQ Boolean bIncludeRowIDs Returns String[]
        Boolean bDone
        Integer iItem iMax iTable iColumn 
        String[] aValues
        Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
        Move 0 to iItem
        Move False to bDone
        While (not(bDone) and iItem<=iMax)
            If (not(bIncludeRowIDs)) Begin
                Move (stQ.aColumnSources[iItem].iColumn=0 and SizeOfArray(stQ.aColumnSources[iItem].aSymbols)=0) to bDone // The ones that are Table.* are excluded
            End
            If (not(bDone)) Begin
                Get ResultColumnValue (&stQ) stQ.aColumnSources[iItem].iTable stQ.aColumnSources[iItem].iColumn to aValues[iItem]
            End
            Increment iItem
        Loop
        Function_Return aValues
    End_Function
    
    //> Returns an array of output column values. If bIncludeRowIDs then also the "columns" that
    //> are in fact a whole record (and they will always be located last) will also be included
    //> (represented by record-rowid).
    Function OutputColumnValues tTableQuery ByRef stQ Boolean bIncludeRowIDs Returns String[]
        Boolean bDone
        Integer iItem iMax iTable iColumn 
        String[] aValues
        Move (SizeOfArray(stQ.aOutputColumns)-1) to iMax
        Move 0 to iItem
        Move False to bDone
        While (not(bDone) and iItem<=iMax)
            If (not(bIncludeRowIDs)) Begin
                Move (stQ.aOutputColumns[iItem].iColumn=0) to bDone // The ones that are Table.* are excluded
            End
            If (not(bDone)) Begin
                If (SizeOfArray(stQ.aOutputColumns[iItem].aSymbols)>0) Begin
                    
                End
                Else Begin
                    Get ResultColumnValue (&stQ) stQ.aOutputColumns[iItem].iTable stQ.aOutputColumns[iItem].iColumn to aValues[iItem]
                End
            End
            Increment iItem
        Loop
        Function_Return aValues
    End_Function
    
    //bSortableValues=False: column values  =True: sortable values
    Function OrderingColumnValues tTableQuery ByRef stQ Returns String[]
        Integer iMax iSegment // iTable
        String[] aValues
        Move (SizeOfArray(stQ.aOrdering)-1) to iMax
        For iSegment from 0 to iMax
            Get _ValueSourceValue (&stQ) stQ.aOrdering[iSegment].stValueSource to aValues[iSegment]
            If (stQ.aOrdering[iSegment].bUppercase) Begin
                Move (Uppercase(aValues[iSegment])) to aValues[iSegment]
            End
        Loop
        Function_Return aValues
    End_Function


            Function __RelateSegmentsToColumns _tTQTableRelationSegment[] aSegments Returns Integer[]
                Integer iItem iMax
                Integer[] aColumns
                Move (SizeOfArray(aSegments)-1) to iMax
                For iItem from 0 to iMax
                    Move aSegments[iItem].iTargetColumn to aColumns[iItem]
                Loop
                Function_Return aColumns
            End_Function

        Procedure _RelateTablePerform tTableQuery ByRef stQ Integer iRelateItem // Is only called when i embedded mode
            Integer iMax iItem iIndex
            Integer iSourceTable iSourceColumn iTargetTable iTargetColumn
            String sValue
            Integer[] aColumns
            tTQTableRelation strRelation

            Move stQ.aTableRelations[iRelateItem] to strRelation

            If (not(strRelation.bFixed)) Begin // If fixed we will just accept the record that is there.
                Move (SizeOfArray(strRelation.aSegments)-1) to iMax

                Move strRelation.iTargetTable to iTargetTable
                Clear iTargetTable
                For iItem from 0 to iMax
                    Move strRelation.aSegments[iItem].iSourceTable to iSourceTable
                    Move strRelation.aSegments[iItem].iSourceColumn to iSourceColumn
                    Move strRelation.aSegments[iItem].iTargetColumn to iTargetColumn
                    Get ResultColumnValue (&stQ) iSourceTable iSourceColumn to sValue
                    Set_Field_Value iTargetTable iTargetColumn to sValue
                Loop
                If (strRelation._iEmbeddedIndex=-1) Begin
                    Get __RelateSegmentsToColumns strRelation.aSegments to aColumns
                    Get FindEQIndex of oIndexFunctions iTargetTable aColumns to iIndex
                    If (iIndex=-1) Begin
                        Send OnError 733 ("Can't identify record in related table "+String(iTargetTable))
                    End
                    Move iIndex to strRelation._iEmbeddedIndex
                    Move strRelation to stQ.aTableRelations[iRelateItem]
                End
                Else Begin
                    Move strRelation._iEmbeddedIndex to iIndex
                End

                Vfind iTargetTable iIndex EQ
                If (not(Found)) Begin
                    Clear iTargetTable
                End
            End
        End_Procedure

    Procedure _RelateToTable tTableQuery ByRef stQ Integer iTable // This is only called for embedded type queries (from the ResultColumnValue function)
        Integer iRelateItem
        Boolean bTableRelated
        tTQTableRelation strRelation
        If (iTable<>stQ.iTable) Begin // If iTable is not the main table of the query

            Get _FindTableRelation stQ iTable to iRelateItem
            If (iRelateItem<>-1) Begin

                Move stQ._stControlBlock.aRelatedRecords[iRelateItem] to bTableRelated
                If (not(bTableRelated)) Begin //

                    Move stQ.aTableRelations[iRelateItem] to strRelation
                    If (not(strRelation.bFixed)) Begin // If no items we will just accept the current record

                        If (IsNullRowID(GetRowID(stQ.iTable))) Begin
                            Clear iTable
                        End
                        Else Begin

                            If (not(_TableRelationAlreadyOK(Self,&stQ,strRelation))) Begin // If not already good by chance.
                                // It could already be OK by chance in which case it will not perform a relate. If the parent
                                // record is the same as for the previous child record. Or if it has been "fixated" by an
                                // outer loop in which case it would be constant. It is the responsability of the
                                // programmer to ensure that tables do have to take on double roles.
                                Send _RelateTablePerform (&stQ) iRelateItem
                            End

                        End
                    End

                    Move True to stQ._stControlBlock.aRelatedRecords[iRelateItem] // update TableRelateState to "performed"
                End
            End
            Else Begin
                Send OnError 734 "Table not related"
            End
        End
    End_Procedure
    
    //> If you are in a situation where you have a defined
    //> query including a table relation scheme. In that 
    //> situation, and without executing the query, you may
    //> call procedure RelateQueryTable to have TQ perform
    //> a relate on the main table od the query.
    //>
    //> NOTE: The procedure should not be used during the 
    //> execution of the query.
    Procedure RelateQueryTable tTableQuery stQ
        Integer iMax iItem
        Send _TableRelateStatesReset (&stQ)
        Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
        For iItem from 0 to iMax
            Send _RelateTablePerform (&stQ) iItem
        Loop
    End_Procedure

    // This is called in preparation for a new record to indicate the related buffers have
    // to be reconsidered and rectified if needed.
    Procedure _TableRelateStatesReset tTableQuery ByRef stQ
        Boolean[] abEmpty
        Move abEmpty to stQ._stControlBlock.aRelatedRecords
        Move (ResizeArray(stQ._stControlBlock.aRelatedRecords,SizeOfArray(stQ.aTableRelations),False)) to stQ._stControlBlock.aRelatedRecords
    End_Procedure

        Function __CompareColumnSource _tTQValueSource strValue1 _tTQValueSource strValue2 Returns Integer
            Boolean bCompleteRecord1 bCompleteRecord2 bIsExpr1 bIsExpr2
            Move (strValue1.iColumn=0) to bCompleteRecord1
            Move (strValue2.iColumn=0) to bCompleteRecord2
            If (bCompleteRecord1=bCompleteRecord2) Begin
                Move (SizeOfArray(strValue1.aSymbols)<>0) to bIsExpr1
                Move (SizeOfArray(strValue2.aSymbols)<>0) to bIsExpr2
                If (bIsExpr1=bIsExpr2) Begin
                    Function_Return (EQ)
                end
                If (bIsExpr1) Begin
                    Function_Return (LT) // expression goes before a non-expression
                End
                Else Begin
                    Function_Return (GT)
                End
            End
            If (bCompleteRecord1) Begin
                Function_Return (GT) // "Complete record" must go to bottom of the list
            End
            Else Begin
                Function_Return (LT)
            End
        End_Function

    //> Add table column to the result set.
    Procedure AddResultColumn tTableQuery ByRef stQ Integer iTable Integer iColumn Boolean bRejectIfAlreadyThere
        Integer iColumnSourceItem
        Boolean _bRejectIfAlreadyThere
        
        If (num_arguments>=4) Begin
            Move bRejectIfAlreadyThere to _bRejectIfAlreadyThere
        End
        Else Begin
            Move False to _bRejectIfAlreadyThere
        End
        
        If (_bRejectIfAlreadyThere) Begin
            Get _ColumnSourceFind stQ iTable iColumn to iColumnSourceItem
            If (iColumnSourceItem>=0) Begin
                Procedure_Return // The column is already there => skip it
            End
        End
        
        If (iTable=stQ.iTable or _FindTableRelation(Self,stQ,iTable)<>-1) Begin // We accept only ourselves or one of our related.
            Move (SizeOfArray(stQ.aColumnSources)) to iColumnSourceItem
            Move iTable to stQ.aColumnSources[iColumnSourceItem].iTable
            Move iColumn to stQ.aColumnSources[iColumnSourceItem].iColumn
            Get _ColumnType iTable iColumn to stQ.aColumnSources[iColumnSourceItem].iType
            If (not(stQ._bOutputColumnsFixated)) Begin
                Move stQ.aColumnSources[iColumnSourceItem] to stQ.aOutputColumns[SizeOfArray(stQ.aOutputColumns)]
            End
            Move (SortArray(stQ.aColumnSources,Self,GET___CompareColumnSource)) to stQ.aColumnSources
        End
        Else Begin
            Send OnError 736 ("Unknown table in result set ("+String(iTable)+")")
        End
    End_Procedure
    
    //> Add an expression to the result set.
    Procedure AddResultColumnExpression tTableQuery ByRef stQ String sExpression Integer iValueType Integer iLength Integer iDecimals 
        Integer hoExprParser
        Integer[] aLegalTables // For expressions
        tXPGrammar stGrammar
        tXPError stError
        _tTQValueSource stValueSource

        Get phoExprParser to hoExprParser
        
        Get LegalExpressionTables stQ to aLegalTables
        Set paAllowedTables of hoExprParser to aLegalTables
        
        Get NewGrammar of hoExprParser to stGrammar
        Get TokenizeString of hoExprParser stGrammar sExpression (&stError) to stValueSource.aSymbols // AddResultColumnExpression
        
//        If (stError.sErrorText="" and SizeOfArray(stValueSource.aSymbols)>0) Begin
            Get ReversePolishNotation of hoExprParser stGrammar stValueSource.aSymbols (&stError) to stValueSource.aSymbols
            If (stError.sErrorText="") Begin

                Move iValueType to stValueSource.iType
                Move iLength to stValueSource.iLen
                Move iDecimals to stValueSource.iDecimals
                Move sExpression to stValueSource.sConstant // Overload of .sConstant. But it's safe. sConstant will not be accessed if .aSymbols contains items

                Move stValueSource to stQ.aColumnSources[SizeOfArray(stQ.aColumnSources)]
                
                If (not(stQ._bOutputColumnsFixated)) Begin
                    Move stValueSource to stQ.aOutputColumns[SizeOfArray(stQ.aOutputColumns)]
                End
                Move (SortArray(stQ.aColumnSources,Self,GET___CompareColumnSource)) to stQ.aColumnSources

            End
            Else Begin
                Send OnError 752 stError.sErrorText
            End
//        End
//        Else Begin
//            Send OnError 751 "(Q3) Cannot add empty expression"
//        End
        Set paAllowedTables of hoExprParser to (ResizeArray(aLegalTables,0))
    End_Procedure
    
    Procedure FixateOutputColumns tTableQuery ByRef stQ
        Move True to stQ._bOutputColumnsFixated
    End_Procedure
    

    Procedure AddResultTable tTableQuery ByRef stQ Integer iTable
        Send AddResultColumn (&stQ) iTable 0
    End_Procedure

    Procedure ResetResultSetColumns tTableQuery ByRef stQ
        // Check that the query is not already executing
        If (stQ._stControlBlock.bInitialized) Begin
            Send OnError 741 "ResetResultSetColumns called while query is executing"
        End
        Else Begin
            Move (ResizeArray(stQ.aColumnSources,0)) to stQ.aColumnSources
            Move (ResizeArray(stQ.aOutputColumns,0)) to stQ.aOutputColumns
        End
    End_Procedure

    Function _IsColumnIncludedInResultSet tTableQuery stQ Integer iTable Integer iColumn Returns Boolean
        Integer iItem iItemMax
        Move (SizeOfArray(stQ.aColumnSources)-1) to iItemMax
        If (stQ.iTable=iTable and iItemMax=-1) Begin
            Function_Return True //
        End
        For iItem from 0 to iItemMax
            If (iTable=stQ.aColumnSources[iItem].iTable) Begin
                If (iColumn=stQ.aColumnSources[iItem].iColumn or stQ.aColumnSources[iItem].iColumn=0) Begin
                    Function_Return True
                End
            End
        Loop
        Function_Return False
    End_Function

// *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions ***


        // If iTable has a name in filelist.cfg we use that, other wise
        // we try the SQL table name.
        Function LogTableName tTableQuery stQ Returns String
            Integer iTable
            String sTableName
            Move stQ.iTable to iTable
            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTableName
            If (sTableName="") Begin
                Move stQ.sForceSQLTableName to sTableName
            End
            If (sTableName<>"") Begin
                Move (sTableName+"_tqlog.dat") to sTableName
            End
            Function_Return sTableName
        End_Function

        Function LogTableNameFullPath tTableQuery stQ Returns String
            String sFolder sTablePath
            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
            Get AppendPath of oFileFunctions sFolder "tq-logdata" to sFolder
            Get AppendPath of oFileFunctions sFolder (LogTableName(Self,stQ)) to sTablePath
            Function_Return sTablePath
        End_Function

#IFNDEF Is$WebApp // If Windows application
        Function LogTableCreate tTableQuery stQ Returns Boolean
            tTempTableDefinition stTable

            Get EmptyTempTableDefinition of oTemporaryTablesFunctions to stTable

            Move 20000 to stTable.iMaxRecords // Max number of logs
            Get LogTableName stQ to stTable.sFileName
            Move "" to stTable.sFolder // blank means it goes in the data folder
            Move "tq-logdata" to stTable.sSubFolder // means it goes in a subfolder of the data folder called "tq-logdata"

            Send AddColumn of oTemporaryTablesFunctions (&stTable) "DateTime"         DF_ASCII    23 0  // field no 1
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "ExecTime"         DF_BCD       8 0  // field no 2
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "LogTag"           DF_ASCII    20 0  // field no 3
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "User"             DF_ASCII    20 0  // field no 4
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "Application"      DF_ASCII    20 0  // field no 5
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "SessionStart"     DF_ASCII    23 0  // field no 6
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "FullTableScan"    DF_BCD       2 0  // field no 7
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "RecordsFound"     DF_BCD      10 0  // field no 8
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "RecordsSelected"  DF_BCD      10 0  // field no 9
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "UnusedFilters"    DF_BCD       4 0  // field no 10
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "Index"            DF_BCD       4 0  // field no 11
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "IndexForced"      DF_BCD       2 0  // field no 12
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "PrefetchForced"   DF_BCD       2 0  // field no 13
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "Limit"            DF_BCD       6 0  // field no 14
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "ScanComplete"     DF_BCD       2 0  // field no 15
            Send AddColumn of oTemporaryTablesFunctions (&stTable) "TQserialised"     DF_BINARY 2040 0  // field no 16
            Move True to stTable.bCompression
            
            If (CreateTable(oTemporaryTablesFunctions,stTable,True)) Begin
//                Showln "LogTableCreate Success"
                Function_Return True
            End
            Else Begin
//                Showln "LogTableCreate Failure"
            End
            Function_Return False
        End_Function
#ENDIF
        
        Function OpenLogTable tTableQuery stQ Returns Integer 
            Integer iLogTable
            String sLogTableName
            Move 0 to iLogTable
            Get LogTableNameFullPath stQ to sLogTableName
            // We do not expect the log file to have an entry in filelist.cfg 
            // so we open it "as".
            If (sLogTableName<>"") Begin
                Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
                If (iLogTable=0) Begin // If the table isn't there, we create it
#IFNDEF Is$WebApp // If Windows application
                    If (LogTableCreate(Self,stQ)) Begin
                        Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
                    End
#ELSE
                    Send OnError 753 ("Log table not found: "+sLogTableName)
#ENDIF
                End
            End
            Else Begin
                // No error! (I changed my mind)
                // Error xxx ("Table name for log file could not be calculated (table: "+String(stQ.iTable)+")")
            End
            Function_Return iLogTable
        End_Function
        
        Function LogTableHandle tTableQuery stQ Returns Integer 
            Integer iLogTable
            Move 0 to iLogTable
            If (stQ.iTable<SizeOfArray(_gaTQLogTables)) Begin
                Move _gaTQLogTables[stQ.iTable] to iLogTable
            End
            If (iLogTable=0) Begin
                // Attempt to open log table
                Get OpenLogTable stQ to iLogTable
                If (iLogTable=0) Begin
                    Move -1 to iLogTable
                End
                Move iLogTable to _gaTQLogTables[stQ.iTable]
            End
            Function_Return iLogTable
        End_Function
        
        Function TableQueryUser Returns String
            Function_Return (NetworkUserName(oWindowsInfo))
        End_Function
        
    Function _FixedTables tTableQuery stQ Boolean bFixed Returns Integer[]
        Integer iMax iIndex
        Integer[] aTables
        Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
        For iIndex from 0 to iMax
            If (stQ.aTableRelations[iIndex].bFixed=bFixed) Begin
                If (IntegerAddToSet(oStackFunctions,&aTables,stQ.aTableRelations[iIndex].iTargetTable)) Begin
                    // Do nothing
                End
            End
        Loop
        Function_Return aTables
    End_Function

    //> Returns an array of tables that are referenced as constants during the execution of a query.
    //> So if you want to repeat the find loop of a particular tTableQuery variable, the record
    //> buffers of fixed tables must be restored to that of the original query. Does this make sense?
    Function FixedTables tTableQuery stQ Returns Integer[]
        Function_Return (_FixedTables(Self,stQ,True))
    End_Function
    
    //> These tables may be referenced from within an expression
    Function LegalExpressionTables tTableQuery stQ Returns Integer[]
        Integer iMax iIndex
        Integer[] aTables
        If (IntegerAddToSet(oStackFunctions,&aTables,stQ.iTable)) Begin
        End
        Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
        For iIndex from 0 to iMax
            If (IntegerAddToSet(oStackFunctions,&aTables,stQ.aTableRelations[iIndex].iTargetTable)) Begin
            End
        Loop
        Function_Return aTables
    End_Function

    //> Same as previous message except opposite.
    Function NotFixedTables tTableQuery stQ Returns Integer[]
        Boolean bGrb
        Integer[] aTables
        Get _FixedTables stQ False to aTables
        Get IntegerAddToSet of oStackFunctions (&aTables) stQ.iTable to bGrb
        Function_Return aTables
    End_Function
    
    Function FixedTablesRowIDs tTableQuery stQ Returns RowID[]
        Integer iItem iMax
        Integer[] aFixedTables
        RowID[] aRowIDs
        Get FixedTables stQ to aFixedTables
        Move (SizeOfArray(aFixedTables)-1) to iItem
        For iItem from 0 to iMax
            Move (GetRowID(aFixedTables[iItem])) to aRowIDs[iItem]
        Loop
        Function_Return aRowIDs
    End_Function
    
    Function FixedTablesRowIDs_Serialized tTableQuery stQ Returns String[]
        Integer iItem iMax
        Integer[] aFixedTables
        String[] aRowIDs
        Get FixedTables stQ to aFixedTables
        Move (SizeOfArray(aFixedTables)-1) to iItem
        For iItem from 0 to iMax
            Move (SerializeRowID(GetRowID(aFixedTables[iItem]))) to aRowIDs[iItem]
        Loop
        Function_Return aRowIDs
    End_Function
    
    Function FixedTablesRestore tTableQuery stQ RowID[] aRowIDs Returns Boolean
        Boolean bFound
        RowID riRow
        Integer iItem iMax
        Integer[] aFixedTables
        Get FixedTables stQ to aFixedTables
        Move (SizeOfArray(aFixedTables)-1) to iMax
        For iItem from 0 to iMax
            Move aRowIDs[iItem] to riRow
            If (IsNullRowID(riRow)) Begin
                Clear aFixedTables[iItem]
            End
            Else Begin
                Move (FindByRowID(aFixedTables[iItem],aRowIDs[iItem])) to bFound
                If (not(bFound)) Begin
                    Function_Return False
                End
            End
        Loop
        Function_Return True
    End_Function
    
    Function FixedTablesRestore_SerializedRowIDs tTableQuery stQ String[] asRowIDs Returns Boolean
        Integer iItem iMax
        RowID[] ariRowIDs
        Move (SizeOfArray(asRowIDs)-1) to iMax
        For iItem from 0 to iMax
            Move (DeserializeRowID(asRowIDs[iItem])) to ariRowIDs[iItem]
        Loop
        Function_Return (FixedTablesRestore(Self,stQ,ariRowIDs))
    End_Function

    Procedure _PushNoneFixedBuffers tTableQuery stQ
        Integer iItem iMax iTable
        Integer[] aTables
        Get NotFixedTables stQ to aTables
        Move (SizeOfArray(aTables)-1) to iMax
        For iItem from 0 to iMax
            Move aTables[iItem] to iTable
            Send PushRecord of oRecordBufferFunctions iTable
        Loop
    End_Procedure
    Procedure _PopNoneFixedBuffers tTableQuery stQ
        Integer iItem iMax iTable
        Integer[] aTables
        Get NotFixedTables stQ to aTables
        Move (ReverseArray(aTables)) to aTables
        Move (SizeOfArray(aTables)-1) to iMax
        For iItem from 0 to iMax
            Move aTables[iItem] to iTable
            Send PopRecord of oRecordBufferFunctions iTable
        Loop
    End_Procedure
    
    //> Serialize a tTableQuery variable into a string. Do not use the string for permanent storage.
    Function TableQueryToString tTableQuery stQ Returns String
        String sTQserialized
        Get VariantToString of oStructFunctions stQ to sTQserialized
        Function_Return sTQserialized
    End_Function

    //> Deserialize a string into a tTableQuery variable.
    Function StringToTableQuery String sTQserialized Returns tTableQuery
        tTableQuery stQ
        tValueTree strValueTree
        Get StringToValueTree of oStructFunctions sTQserialized to strValueTree
        ValueTreeDeserializeParameter strValueTree to stQ
        Function_Return stQ
    End_Function

    Function TableQuerySerializedForLog tTableQuery stQ Returns String
        String sTQserialized
        Get TableQueryToString stQ to sTQserialized
        Function_Return ("V1.0,"+sTQserialized)
    End_Function
    Function SerializedLogToTableQuery String sTQserialized Returns tTableQuery
        tTableQuery stQ
        If (Left(sTQserialized,5)="V1.0,") Begin
            Move (Replace("V1.0,",sTQserialized,"")) to sTQserialized
            Get StringToTableQuery sTQserialized to stQ
        End
        Function_Return stQ
    End_Function
        
            Function _NextValueInArray String[] aValues Integer ByRef iPos Returns String
                String sValue
                Move aValues[iPos] to sValue
                Increment iPos
                Function_Return sValue
            End_Function
        
                Function _LogReadValueSource String[] aValues Integer ByRef iPos Returns _tTQValueSource
                    _tTQValueSource stValue
                    Integer iItem iMax
                    Get _NextValueInArray aValues (&iPos) to stValue.iTable   
                    Get _NextValueInArray aValues (&iPos) to stValue.iColumn  
                    Get _NextValueInArray aValues (&iPos) to stValue.iType    
                    Get _NextValueInArray aValues (&iPos) to stValue.iLen     
                    Get _NextValueInArray aValues (&iPos) to stValue.iDecimals
                    Get _NextValueInArray aValues (&iPos) to stValue.sConstant
                    Get _NextValueInArray aValues (&iPos) to stValue.sSQLResultSetColumnName
                    Get _NextValueInArray aValues (&iPos) to iMax
                    For iItem from 0 to iMax
                        Get _NextValueInArray aValues (&iPos) to stValue.aOrList[iItem]
                    Loop
                    Function_Return stValue
                End_Function

            Function _LogReadFilter String[] aValues Integer ByRef iPos Returns tTQFilterSegment
                tTQFilterSegment stFilter
                Get _LogReadValueSource aValues (&iPos) to stFilter.stLeftValue
                Get _NextValueInArray aValues (&iPos) to stFilter.iComp
                Get _LogReadValueSource aValues (&iPos) to stFilter.stRightValue
            End_Function
            
            Function _LogReadOrderingSegment String[] aValues Integer ByRef iPos Returns tTQOrderBySegment
                tTQOrderBySegment stSegment
                Get _NextValueInArray aValues (&iPos) to stSegment.bDescending
                Get _NextValueInArray aValues (&iPos) to stSegment.bUppercase
                Get _LogReadValueSource aValues (&iPos) to stSegment.stValueSource
            End_Function
        
        Function TableQueryDeserializedFromLog String sValue Returns tTableQuery
            Integer iPos iItem iMax
            tTableQuery stQ 
            tTQFilterSegment stFilter
            tTQOrderBySegment stSegment
            String[] aValues
            Send SplitString of oStringFunctions sValue (Character(10)) False False (&aValues)
            If (SizeOfArray(aValues)>1) Begin
                Move 1 to iPos
                If (aValues[0]="V1.0") Begin
                    Get _NextValueInArray aValues (&iPos) to stQ.iTable
                    Get _NextValueInArray aValues (&iPos) to stQ.bNoESQL
                    Get _NextValueInArray aValues (&iPos) to stQ.bForcePrefetch
                    Get _NextValueInArray aValues (&iPos) to stQ.iForceIndex
                    Get _NextValueInArray aValues (&iPos) to stQ.iLimit        
                    // Filters:
                    Get _NextValueInArray aValues (&iPos) to iMax
                    For iItem from 0 to iMax
                        Get _LogReadFilter aValues (&iPos) to stFilter
                        Move stFilter to stQ.aFilters[iItem]    
                    Loop
                    // Ordering:
                    Get _NextValueInArray aValues (&iPos) to iMax
                    For iItem from 0 to iMax
                        Get _LogReadOrderingSegment aValues (&iPos) to stSegment
                        Move stSegment to stQ.aOrdering[iItem]    
                    Loop
                End
            End
            Function_Return stQ
        End_Function

    Procedure OnLogStatus tTableQuery stQ
        Boolean bVal
        Integer iLogTable iSize iValue
        String sModule sValue
        Get LogTableHandle stQ to iLogTable
        If (iLogTable>0) Begin
            Clear iLogTable

            Get SystemTimeToString23 of oDateFunctions (SystemTimeMilliSeconds(oDateFunctions)) to sValue
            Set_Field_Value iLogTable 1 to sValue
            // No meaningful value to put into ExecTime (field 2)
            Set_Field_Value iLogTable 3 to stQ._stControlBlock.sLogTag
            Get TableQueryUser to sValue
            Set_Field_Value iLogTable 4 to sValue  // (TableQueryUser(Self))
            Get Module_Name to sModule
            Set_Field_Value iLogTable 5 to sModule
            Get ModuleStartTime of oDateFunctions to sValue
            Set_Field_Value iLogTable 6 to sValue
            Move (SizeOfArray(stQ._stCompiled.aJumpInValues)=0 and SizeOfArray(stQ._stCompiled.aJumpOutValues)=0 and stQ.iLimit=0) to bVal
            Set_Field_Value iLogTable 7 to bVal // Full table scan
            Set_Field_Value iLogTable 8 to stQ._stControlBlock.iFindCount
            Set_Field_Value iLogTable 9 to stQ._stControlBlock.iSelectCount
            Move (SizeOfArray(stQ._stCompiled.aOtherConditions)) to iSize
            Set_Field_Value iLogTable 10 to iSize // Unused filters
            Set_Field_Value iLogTable 11 to stQ._stCompiled.iIndex
            Move (stQ.iForceIndex<>-1) to iValue
            Set_Field_Value iLogTable 12 to iValue
            Set_Field_Value iLogTable 13 to stQ.bForcePrefetch
            Set_Field_Value iLogTable 14 to stQ.iLimit
            Set_Field_Value iLogTable 15 to (not(stQ._stControlBlock.bBreakScan))
            Get TableQuerySerializedForLog stQ to sValue
            Set_Field_Value iLogTable 16 to sValue
            
            SaveRecord iLogTable
        End
    End_Procedure
        
    Procedure OnComplete tTableQuery stQ
    End_Procedure
    
        Procedure _RelateMainRecord tTableQuery ByRef stQ
            Integer iItem iItemMax
            Move (SizeOfArray(stQ.aColumnSources)-1) to iItemMax
            For iItem from 0 to iItemMax
                If (stQ.aColumnSources[iItem].iTable>0) Begin // If it's an expression there is no table to relate to.
                    Send _RelateToTable (&stQ) stQ.aColumnSources[iItem].iTable
                End
            Loop
        End_Procedure
        
        Procedure _CalculateBreakLevel tTableQuery ByRef stQ 
            Integer iMax iItem
            String[] aNewValues
            
            If (stQ.bBreakLevelTest) Begin
                Get OrderingColumnValues (&stQ) False to aNewValues
    
                Move (SizeOfArray(aNewValues)-1) to iMax
                If (iMax>=0) Begin // No ordering => no break
                    
                    If (SizeOfArray(stQ._stControlBlock.aOldBreakValues)>0) Begin
                        For iItem from 0 to iMax
                            If (aNewValues[iItem]<>stQ._stControlBlock.aOldBreakValues[iItem]) Begin
                                Move aNewValues to stQ._stControlBlock.aOldBreakValues
                                Move iItem to stQ._stControlBlock.iCurrentRecordBreakLevel // Result!
                                Procedure_Return
                            End
                        Loop
                    End
                    Else Begin
                        Move aNewValues to stQ._stControlBlock.aOldBreakValues
                        Move 0 to stQ._stControlBlock.iCurrentRecordBreakLevel // Most significan break!
                        Procedure_Return
                    End
                End
            End
            Move -1 to stQ._stControlBlock.iCurrentRecordBreakLevel // no break
        End_Procedure

    //> This function should always be called in a while structure:
    //> <code>
    //>  while (FindRecord(oTQ,&stQuery))
    //>    ... do something with the record ...
    //>  loop
    //> </code>
    Function FindRecord tTableQuery ByRef stQ Returns Boolean
        Boolean bFound bInitialize

        Move False to bInitialize

        If (stQ._stControlBlock.bCompiled) Begin
            If (not(stQ._stControlBlock.bInitialized)) Begin
                Move True to bInitialize // Initialize!
            End
        End
        Else Begin
            Get _CompileQuery (&stQ) to bInitialize // If it compiles we will initialize it
        End

        If (bInitialize) Begin
            If (_InitializeQuery(Self,&stQ)) Begin
                Move True to stQ._stControlBlock.bInitialized
                Get _FindFirstRecord (&stQ) to bFound
            End
            Else Begin
                Move False to bFound
            End
            Move True to stQ._stControlBlock.bFirstRecord
            
            Move (ResizeArray(stq._stControlBlock.aOldBreakValues,0)) to stq._stControlBlock.aOldBreakValues // Starts blank
        End
        Else Begin
            // This is the mechanism that enforces iLimit. However, if the record set is pre-fetched
            // this has already been taken care of.
            if (stQ._stCompiled._iLimit<>0) Begin
                If (not(stQ._stCompiled.bPrefetch) and stQ._stControlBlock.iSelectCount>=stQ._stCompiled._iLimit) Begin
                    Move True to stQ._stControlBlock.bBreakScan
                End
            End

            Get _FindNextRecord (&stQ) to bFound
            Move False to stQ._stControlBlock.bFirstRecord
        End

        If (bFound) Begin
            If (stQ._stControlBlock.iQueryMethod=tqDATAFLEX) Begin
                // If we are in embedded mode we must find all parent related records specified by the aSelectedColumns member.
                Send _RelateMainRecord (&stQ)
            End
            Else Begin
                // If we are in ESQL mode we expect the fetch-record mechnism to have already done this
            End
        End
        Else Begin
            If (not(stQ.bForcePrefetch)) Begin
                Send PurgeResultSet (&stQ) // if we didn't ask for it we'll get rid of it here (if it's there at all)
            End
            If (_giTQLogState=2 or ( _giTQLogState=1 and stQ._stControlBlock.sLogTag<>"")) Begin
                Send OnLogStatus stQ
            End
            Send _DeinitializeQuery (&stQ) // Get rid of SQL handles (if emploid)
            Send OnComplete stQ
            If (stQ.bRestoreRecordBuffersOnQueryCompletion) Begin
                Send _PopNoneFixedBuffers stQ // restore buffers of tables that were possibly changed by the query
            End
            // This is where we _*ALWAYS*_ exit the FindRecord loop
        End

        If (stQ.bBreakLevelTest) Begin // If break level testing is on
            Send _CalculateBreakLevel (&stQ) 
        End

        Function_Return bFound
    End_Function

    //> Returns true if the current record this is the first record of the result set. For 
    //> use inside the FindRecord loop only.
    Function IsFirstRecord tTableQuery stQ Returns Boolean
        Function_Return stQ._stControlBlock.bFirstRecord
    End_Function
    
    //> If SetBreakLevelTest has been enabled before execution of the query then calling BreakLevel
    //> will inform of break level caused by the current record (-1 if no break).
    Function BreakLevel tTableQuery stQ Returns Integer
        Function_Return stQ._stControlBlock.iCurrentRecordBreakLevel
    End_Function
    
    //> Returns the current row number of the result set.
    Function ResultRowNumber tTableQuery stQ Returns Integer
        If (stQ._stCompiled.bPrefetch) Begin
            Function_Return (stQ.stResultSet._iCurrentRowPointer+1)
        End
        Function_Return stQ._stControlBlock.iSelectCount // Changed from .FindCount 19/6-2018
    End_Function

    Function SelectCount tTableQuery stQ Returns Integer
        Function_Return stQ._stControlBlock.iSelectCount
    End_Function

    //> You may call this function prior to actually running the query to make
    //> sure that the query will actually return any records at all.
    //> Or you may be call it after running the query in which case it will return true
    //> if any records were found.
    Function HasData tTableQuery stQ Returns Boolean
        Boolean bHasData
        tTQOrderBySegment[] aEmpty
        If (stQ._stControlBlock.bInitialized) Begin
            // If the query has already been initialized the function will return whether or
            // not any records have been selected yet (this would only ever be relevant to a
            // person subclassing the cTableQuery class). More relevant is the fact that this
            // means that you can query HasData after loop completion and get to know if the
            // loop was ever executed.
            Function_Return (stQ._stControlBlock.iSelectCount<>0)
        End
        Else Begin
            // If the loop hasn't yet been initialized we will produce the simplest
            // possible query to find out if the loop will have any data.
            Move False to stQ.bForcePrefetch // Prefetch would be stupid
            Move aEmpty to stQ.aOrdering // Do not dictate the ordering
            Move 1 to stQ.iLimit // This will prevent the complete set being built.
            Move -1 to stQ.iForceIndex // Do not force any particular index
            Move False to stQ.bBreakLevelTest // Not necessary
            
            // Dilemma! If there are no non-optimizable filters then it's faster to not use
            //          ESQL. But then I have to compile the query before executing the loop.
            //          I just haven't gotten around to that yet.
            // Move True to stQ.bNoESQL // (do not use ESQL)
            
            Move False to bHasData
            While (FindRecord(Self,&stQ))
                Move True to bHasData
            Loop
        End
        Function_Return bHasData
    End_Function

    //> If you have defined a query but want to run it on an alias buffer table you may call ReplaceTableReferences
    //> to have all references to this table substituted for references to another. Advanced use.
    Procedure ReplaceTableReferences tTableQuery ByRef stQ Integer iFromTable Integer iToTable 
        Integer iMax iItem
        Integer iMax2 iItem2

        Move (SizeOfArray(stQ.aColumnSources)-1) to iMax
        for iItem from 0 to iMax
            If (stQ.aColumnSources[iItem].iTable=iFromTable) Begin
                Move iToTable to stQ.aColumnSources[iItem].iTable
            End
        Loop
        
        Move (SizeOfArray(stQ.aOutputColumns)-1) to iMax
        For iItem from 0 to iMax
            If (stQ.aOutputColumns[iItem].iTable=iFromTable) Begin
                Move iToTable to stQ.aOutputColumns[iItem].iTable
            End
        Loop
        
        Move (SizeOfArray(stQ.aFilters)-1) to iMax
        for iItem from 0 to iMax
            If (stQ.aFilters[iItem].stLeftValue.iTable=iFromTable) Begin
                Move iToTable to stQ.aFilters[iItem].stLeftValue.iTable
            End
            If (stQ.aFilters[iItem].stRightValue.iTable=iFromTable) Begin
                Move iToTable to stQ.aFilters[iItem].stRightValue.iTable
            End
        Loop
        
        Move (SizeOfArray(stQ.aOrdering)-1) to iMax
        for iItem from 0 to iMax
            If (stQ.aOrdering[iItem].stValueSource.iTable=iFromTable) Begin
                Move iToTable to stQ.aOrdering[iItem].stValueSource.iTable
            End
        Loop
        
        Move (SizeOfArray(stQ.aTableRelations)-1) to iMax
        For iItem from 0 to iMax
            If (stQ.aTableRelations[iItem].iTargetTable=iFromTable) Begin
                Move iToTable to stQ.aTableRelations[iItem].iTargetTable
            End
            Move (SizeOfArray(stQ.aTableRelations[iItem].aSegments)-1) to iMax2
            for iItem2 from 0 to iMax2
                If (stQ.aTableRelations[iItem].aSegments[iItem2].iSourceTable=iFromTable) Begin
                    Move iToTable to stQ.aTableRelations[iItem].aSegments[iItem2].iSourceTable
                End
            Loop
        Loop
        
        If (stQ.iTable=iFromTable) Begin
            Move iToTable to stQ.iTable 
        End
    End_Function

    //> This majesticly named procedure clears all cached values and closes
    //> any log tables that might have been opened.
    //>
    //> It is never used by a normal program.
    Procedure ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles
        Integer iItem iMax iLogTable
        Move (SizeOfArray(_gaTQLogTables)-1) to iMax
        For iItem from 0 to iMax
            Move _gaTQLogTables[iItem] to iLogTable
            If (iLogTable>0) Begin
                Send CloseTable of oTableAccessFunctions iLogTable
            End
        Loop
        Move (ResizeArray(_gTQaTableMeta,0)) to _gTQaTableMeta
        Move (ResizeArray(_gTQaTableAnalysis,0)) to _gTQaTableAnalysis
        Move (ResizeArray(_gaTQLogTables,0)) to _gaTQLogTables
    End_Procedure
    
    Function QueryToRowIdArray tTableQuery ByRef stQ Returns RowID[]
        Boolean bOriginalBreakLevelTest
        Integer iTable iCount
        RowID[] aRecords
        Move stQ.iTable to iTable
        Move 0 to iCount
        Move stQ.bBreakLevelTest to bOriginalBreakLevelTest
        Move False to stQ.bBreakLevelTest
        While (FindRecord(Self,&stQ))
            Move (GetRowID(iTable)) to aRecords[iCount]
            Increment iCount
        Loop
        Move bOriginalBreakLevelTest to stQ.bBreakLevelTest
        Function_Return aRecords    
    End_Function
    

        Function _TableRootNameStripDriver String sRootName Returns String
            Integer iPos
            Move (Pos(":",sRootName)) to iPos
            If (iPos>2) Begin
                Move (Remove(sRootName,1,iPos)) to sRootName
            End
            Function_Return sRootName
        End_Function

        Function _TableAnalysisFileName Integer iTable Returns String
            String sFolder sTableName
            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
            Get_Attribute DF_FILE_ROOT_NAME of iTable to sTableName
            Get _TableRootNameStripDriver sTableName to sTableName
            Get PathStripType of oFileFunctions sTableName to sTableName
            Get AppendPath of oFileFunctions sFolder (sTableName+".tq") to sTableName
            Function_Return sTableName
        End_Function

            Function _TableAnalysisReadIndex Integer iChannel Returns _tTQIndexAnalysis
                Integer iItem iMax
                _tTQIndexAnalysis stIndexA
                Readln iMax
                For iItem from 0 to iMax
                    Get Readln of oFileFunctions iChannel to stIndexA.aSegmentReductions[iItem]
                Loop
                Function_Return stIndexA
            End_Function
        
        Function TableAnalysisRead Integer iTable tTQTableAnalysis ByRef strA Returns Boolean
            Integer iChannel iItem iMax
            String sFile
            tTQTableAnalysis stEmpty
            Move stEmpty to strA
            Get _TableAnalysisFileName iTable to sFile
            Get DirectInput of oFileFunctions sFile to iChannel
            If (iChannel>=0) Begin
                If (Readln(oFileFunctions,iChannel)="VER 1.0") Begin
                    Get StringToDateTime of oDateFunctions (Readln(oFileFunctions,iChannel)) DF_DATE_MILITARY to strA.dtAnalysisDateTime
                    Readln channel iChannel strA.nNumberOfRecords
                    Readln strA.sTimeToComplete
                    Readln iMax
                    For iItem from 0 to iMax
                        Get _TableAnalysisReadIndex iChannel to strA.aIndices[iItem]
                    Loop
                    Send CloseInput of oFileFunctions iChannel
                    Function_Return True
                End
                Else Begin
                    Send OnError 737 ("TQ cache file not recognized ("+sFile+")")
                End
                Send CloseInput of oFileFunctions iChannel
            End
            Function_Return False
        End_Function

        Procedure _TableAnalysisSaveIndex Integer iChannel _tTQIndexAnalysis stIndexA
            Integer iMax iItem
            Move (SizeOfArray(stIndexA.aSegmentReductions)-1) to iMax
            Writeln channel iChannel iMax
            For iItem from 0 to iMax
                Writeln stIndexA.aSegmentReductions[iItem]
            Loop
        End_Procedure
        
    Function TableAnalysisSave Integer iTable tTQTableAnalysis strA Returns Boolean
        Integer iChannel iItem iMax
        String sFile
        Get _TableAnalysisFileName iTable to sFile
        Get DirectOutput of oFileFunctions sFile to iChannel
        If (iChannel>=0) Begin
            Writeln channel iChannel "VER 1.0"
            Writeln (DateTimeToString(oDateFunctions,strA.dtAnalysisDateTime,DF_DATE_MILITARY,True,"-"))
            Writeln strA.nNumberOfRecords
            Writeln strA.sTimeToComplete
            Move (SizeOfArray(strA.aIndices)-1) to iMax
            Writeln iMax
            For iItem from 0 to iMax
                Send _TableAnalysisSaveIndex iChannel strA.aIndices[iItem]
            Loop
            Send CloseOutput of oFileFunctions iChannel
            Function_Return True
        End
        Function_Return False
    End_Function
    
        Function _TableAnalysisDefault Integer iTable Returns tTQTableAnalysis
            Integer iIndex iItem iMax 
            Integer iSegment iSegments
            Integer[] aIndices
            Number nRecordCount nFactor
            tocIndex stIndex
            tTQTableAnalysis strA

            Get IndexSet of oIndexFunctions iTable 3 to aIndices // 3 means all online indices
            Get_Attribute DF_FILE_RECORDS_USED of iTable 0 0 to nRecordCount
            
            Move (SizeOfArray(aIndices)-1) to iMax
            For iItem from 0 to iMax
                Move aIndices[iItem] to iIndex
                Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to stIndex
                Move (SizeOfArray(stIndex.aSegments)) to iSegments

                Move (nRecordCount^(1.0/iSegments)) to nFactor
                Move (1.0/nFactor) to nFactor

                Decrement iSegments
                For iSegment from 0 to iSegments
                    Move nFactor to strA.aIndices[iIndex].aSegmentReductions[iSegment]
                    // The next line makes sure that a more-segments index is chosen over
                    // a less-segments one, if all else is equal. This is done by 
                    // bettering the factor with a promille for every segment we move down.
                    // Without the line, it would be a fact that the seeding of one segment
                    // in a two segment index would be exactly as lucrative as the seeding
                    // of two segments in a 4 segment index. EVEN if the most significant
                    // segment of both indices is the same.
                    // Sture april 24th 2016.
                    Move (nFactor*0.999) to nFactor
                Loop
            Loop
            Function_Return strA 
        End_Function
    
    //> The TableAnalysis returns information that helps the index analyzer
    //> to make informed guesses about which index seeds the best. VDFxray can be used to generate
    //> a small text file for each table with this information. If this is the case then function
    //> TableAnalysis will read that file and return the by now much mentioned information. And if not,
    //> the best possible guess is calculated and returned. Actually, in addition to being returned
    //> by the function it is also copied to a global cache so subsequent calls will take no time.
    Function TableAnalysis Integer iTable Returns tTQTableAnalysis
        tTQTableAnalysis strA

        Move False to strA.bInitialized
        If (SizeOfArray(_gTQaTableAnalysis)>iTable and _gTQaTableAnalysis[iTable].bInitialized) Begin
            Move _gTQaTableAnalysis[iTable] to strA
        End
        Else Begin
            If (not(TableAnalysisRead(Self,iTable,&strA))) Begin
                Get _TableAnalysisDefault iTable to strA // Calculate one    
            End
            Move True to strA.bInitialized
            Move strA to _gTQaTableAnalysis[iTable]
        End
        Function_Return strA
    End_Function
    
    //> Information about configuration of indices for a table. A caching mechanism makes sure that
    //> this configuration is not read on subsequent calls to the function.
    Function TableMeta Integer iTable Returns tTQTableMeta
        tTQTableMeta strM
        Move 0 to strM._iIsInitialized
                                                
        If (SizeOfArray(_gTQaTableMeta)>iTable and _gTQaTableMeta[iTable]._iIsInitialized<>0) Begin
            Move _gTQaTableMeta[iTable] to strM
        End
        Else Begin
            Get IndexSet of oIndexFunctions iTable 3 to strM.aIndices // 3 means all on-line indices
            Move 1 to strM._iIsInitialized
            Move strM to _gTQaTableMeta[iTable]
        End
        
        Function_Return strM
    End_Function
    
    Function TableIndices Integer iTable Returns Integer[]
        tTQTableMeta strM
        Get TableMeta iTable to strM
        Function_Return strM.aIndices
    End_Function
    
End_Class // cTableQueryFunctions


Global_Variable Integer oTQ //> Holder of the global object for manipulating and executing table queries

Object _oTQ is a cTableQueryFunctions
    Move Self to oTQ
    // Is called by VDFXray when new WS is selected (TableQuery.pkg is used by VDFXray)
    Procedure OnNewFilelistSelected
        Send ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles
    End_Procedure
End_Object


Class cTableQueryAnalyzer is a cObject
        Function _BreakLevel String[] aNewValues String[] aOldValues Returns Integer
            Integer iMax iItem
            Move (SizeOfArray(aNewValues)-1) to iMax
            For iItem from 0 to iMax
                If (aNewValues[iItem]<>aOldValues[iItem]) Begin
                    Function_Return iItem
                End
            Loop
            Function_Return -1 // no break
        End_Function

        Procedure _IncrementBreakCounter Integer[] ByRef aBreakCounters Integer iLevel
            Integer iMax iItem
            If (iLevel>=0) Begin
                Move (SizeOfArray(aBreakCounters)-1) to iMax
                For iItem from 0 to iMax
                    If (iItem>=iLevel) Begin
                        Move (aBreakCounters[iItem]+1) to aBreakCounters[iItem]
                    End
                Loop
            End
        End_Procedure

        Procedure _AnalyseTableIndexAux _tTQIndexAnalysis ByRef stIndexA Integer iTable Integer iIndex Integer[] aBreakCounters
            Integer iMax iItem
            Number nFactor
            Move (ResizeArray(stIndexA.aSegmentReductions,0)) to stIndexA.aSegmentReductions
            Move (SizeOfArray(aBreakCounters)-1) to iMax
            For iItem from 0 to iMax
                If (iItem=0) Begin
                    Move (1.0/aBreakCounters[iItem]) to nFactor
                End
                Else Begin // 211 644 2200 11331 => 1/211, 211/644, 644/2200, 2200/11331
                    Move (Number(aBreakCounters[iItem-1])/aBreakCounters[iItem]) to nFactor
                End
                Move nFactor to stIndexA.aSegmentReductions[iItem]
            Loop
        End_Procedure
    
    Procedure _AnalyseTableIndex _tTQIndexAnalysis ByRef stIndexA Integer iTable Integer iIndex
        Integer iCount iLevel iMax
        String[] aNewValues aOldValues
        Integer[] aBreakCounters
        tocIndex stIndex
        _tTQIndexAnalysis stEmpty
        tTableQuery stQ
        
        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to stIndex

        Move 0 to iCount
        Get_Attribute DF_FILE_RECORDS_USED of iTable to iMax

        Get NewQuery of oTQ iTable to stQ
        Send SetOrderByToIndex of oTQ (&stQ) iIndex
        
        While (FindRecord(oTQ,&stQ))
            Increment iCount
            
            Get IndexSegmentValueArray of oIndexFunctions iTable iIndex to aNewValues
            If (iCount=1) Begin
                Move (ResizeArray(aBreakCounters,SizeOfArray(aNewValues))) to aBreakCounters
                Move aNewValues to aOldValues // No break on the first one
            End

            If (((iCount/5000)*5000)=iCount) Begin
                Send OnAnalyseIndexProgress iTable iCount iMax
            End

            Get _BreakLevel aNewValues aOldValues to iLevel
            If (iLevel>=0) Begin
                Send _IncrementBreakCounter (&aBreakCounters) iLevel
            End

            Move aNewValues to aOldValues
        Loop

        Send OnAnalyseIndexProgress iTable iCount iCount

        If (iCount<>0) Begin
            Send _IncrementBreakCounter (&aBreakCounters) 0
        End

        Move stEmpty to stIndexA
        Send _AnalyseTableIndexAux (&stIndexA) iTable iIndex aBreakCounters
    End_Procedure

    Procedure OnAnalyseTableIndex Integer iTable Integer iIndex Integer iIndexIndex Integer IndexCount
    End_Procedure

    Procedure OnAnalyseTable Integer iTable Integer iIndexCount
    End_Procedure

    Procedure OnAnalyseIndexProgress Integer iTable Integer iCount Integer iMax
    End_Procedure

    Procedure AnalyzeTable tTQTableAnalysis ByRef stTableA Integer iTable
        Integer iItem iMax iIndex
        Integer[] aIndices
        Number nElapsed nRecords
        tSystemTimeMS stStart stStop
        tTQTableAnalysis stEmptyTable
        _tTQIndexAnalysis stIndexA
        Move stEmptyTable to stTableA
        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecords

        If (nRecords>100) Begin
            Get SystemTimeMilliSeconds of oDateFunctions to stStart

            Get_Attribute DF_FILE_RECORDS_USED of iTable to stTableA.nNumberOfRecords
            Get IndexSet of oIndexFunctions iTable 3 to aIndices // All on-line indices
            Move (SizeOfArray(aIndices)-1) to iMax

            Send OnAnalyseTable iTable (iMax+1)

            For iItem from 0 to iMax
                Move aIndices[iItem] to iIndex
                Send OnAnalyseTableIndex iTable iIndex iItem (iMax+1)
                Send _AnalyseTableIndex (&stIndexA) iTable iIndex
                Move stIndexA to stTableA.aIndices[iIndex]
            Loop
            Send OnAnalyseTableIndex iTable iIndex (iMax+1) (iMax+1)
            Get SystemTimeMilliSeconds of oDateFunctions to stStop
            Get SystemTimeMilliSecondsElapsed of oDateFunctions stStart stStop to nElapsed
            Get MilliSecondsToTimeString of oDateFunctions nElapsed to stTableA.sTimeToComplete

            Get SystemDateTime of oDateFunctions to stTableA.dtAnalysisDateTime
        End
    End_Procedure

    Procedure DeleteAnalysis Integer[] aTables
        Integer iItem iMax iFailure
        String sFile
        Move (SizeOfArray(aTables)-1) to iMax
        For iItem from 0 to iMax
            Get _TableAnalysisFileName of oTQ aTables[iItem] to sFile
            If (FileExists(oFileFunctions,sFile)=1) Begin
                Get DeleteFileNew of oFileFunctions sFile True to iFailure
            End
        Loop
    End_Procedure

End_Class

Class cTableQueryTester is a cObject
    // Based on a tTableQuery value stQ, TestSuite will return
    // an array of all queries that should return the same resultset.
    Function TestSuite tTableQuery stQ Returns tTableQuery[]
        Integer iForcePrefetch iItem iMax
        tTableQuery[] aQueries
        Integer[] aIndices
        Send ReUse of oTQ (&stQ)
        Move False to stQ._stControlBlock.bCompiled
        Get TableIndices of oTQ stQ.iTable to aIndices
        Move (SizeOfArray(aIndices)-1) to iMax
        For iForcePrefetch from 0 to 1
            Move (iForcePrefetch=1) to stQ.bForcePrefetch
            For iItem from 0 to iMax
                Send ForceIndex of oTQ (&stQ) aIndices[iItem]
                Move stQ to aQueries[SizeOfArray(aQueries)]
            Loop
        Loop
        Function_Return aQueries
    End_Function

        Function CompareRowID RowID ri1 RowID ri2 Returns Integer
            If (IsSameRowID(ri1,ri2)) Begin
                Function_Return (EQ)
            End
            Function_Return (GT)
        End_Function

        Function ResultSetsIdentical RowID[] aResult1 RowID[] aResult2 Returns Boolean
            Integer iMax iItem iItem2
            Move (SizeOfArray(aResult1)-1) to iMax
            If (iMax=(SizeOfArray(aResult2)-1)) Begin
                For iItem from 0 to iMax
                    Move (SearchArray(aResult1[iItem],aResult2,Self,GET_CompareRowID)) to iItem2
                    If (iItem2=-1) Begin
                        Function_Return False
                    End
                Loop
                Function_Return True
            End
            Function_Return False
        End_Function

        Procedure OnNotIdentical tTableQuery strQ1 tTableQuery strQ2
        End_Procedure

    Function RunSuite tTableQuery[] ByRef aQueries Returns RowID[][]
        Integer iItem iMax
        Boolean bIdentical
        RowID[] aResult
        RowID[][] aMatrix // An array of result-arrays
        Move (SizeOfArray(aQueries)-1) to iMax
        For iItem from 0 to iMax
            Get QueryToRowIdArray of oTQ (&aQueries[iItem]) to aResult
            Move aResult to aMatrix[iItem]
        Loop
        Function_Return aMatrix
    End_Function
End_Class // cTableQueryTester

