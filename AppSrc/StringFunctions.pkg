// String functions encapsulated in oStringFunctions (SturesPublicLibrary)

//> The oStringFunctions.pkg package defines an object called oStringFunctions that encapsulates a number of
//> general purpose string functions.
//>
//> For example, to call the function NumberToString the syntax is therefore
//>
//> <code>
//>  get NumberToString of oStringFunctions 3.1415926 3 to sResult
//> </code>
//>
//> or on expressional form
//>
//> <code>
//>  move (NumberToString(oStringFunctions,3.1415926,3)) to sResult
//> </code>
//>
//> (both of the above examples places the result "3.142" in string variable sResult)
//>
//> Since quite a number of functions in this package are concerned with formatting numbers
//> a general note is in its place. Converting numbers to strings was never very difficult
//> in VDF. Simply move a number to a string, end of conversion. However, that type of conversion
//> leaves you no control over the number of decimals in the resulting string.
//>
//> <code>
//>  String sValue
//>  Move 2.500 to sValue
//> </code>
//>
//> places the value "2.5" in the string variable because a number moved to a string variable
//> gets truncated at the least significant digit that is non-zero (after the decimal point). The
//> NumberToString function mentioned just above, or one of its cousins, helps you overcome this.
//>
//> pkg.doc.end

Use VdfBase.pkg // DAW package. Provides low level support expected of all DF applications (windows and webapp)

//> Internally for use with wildcard* functions
Enum_List
    Define _WILDC_THE_HARD_WAY         //> The hard way
    Define _WILDC_ALWAYS_TRUE          //> *
    Define _WILDC_EQUAL                //> Sture
    Define _WILDC_LEFT_MATCH           //> Sture*
    Define _WILDC_RIGHT_MATCH          //> *Andersen
    Define _WILDC_LEFT_AND_RIGHT_MATCH //> Sture*Andersen
    Define _WILDC_CONTAINS             //> *B*
    Define _WILDC_CONTAINS_WORDONLY
End_Enum_List

Enum_List
    Define _WILDC_CONSTANT
    Define _WILDC_QUESTIONMARK
    Define _WILDC_ASTERISK
End_Enum_List

Struct tWildCardEvalSequenceItem
    Integer iType // 0=constant 1=? 2=*
    String sValue // Only relevant when iType is 0
End_Struct

//> A value of this type describes a series of string comparisons to perform
//> in order to validate a string against a particular mask. The WildCard* functions
//> defined in the cStringFunctions class uses this.
Struct tWildCardEvalSequence
    // The properties defined here are used only to try to optimize
    // the evaluation sequence.
    Integer iAltStrategy
    // If an alternative strategy is active, can we use it to accept a
    // value (bAltStrategyRejectOnly=TRUE) or must we run it the hard
    // way afterwards (bAltStrategyRejectOnly=FALSE)?
    Boolean bAltStrategyRejectOnly
    String  sAltStrategyLeftValue
    String  sAltStrategyRightValue
    tWildCardEvalSequenceItem[] aSequence
End_Struct

String gStr$ReversedCollateString 255

Struct _tsfMaxArgSize
    Integer iSize
    Boolean bSet
End_Struct

Global_Variable _tsfMaxArgSize[] _gasfMAS

//> The oStringFunctions global object is based on the cStringFunctions class.
Class _cStringFunctions is a cObject
    
    Procedure Construct_Object
        Integer iAscii
        Forward Send Construct_Object
        //> The coolest little property
        Property String psDecimalSeparator
        Property Boolean _pbInsertThousandsSeparators False

        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
        Set psDecimalSeparator to (Character(iAscii))
        
        Property String psWildCardWordCharacters "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_#0123456789"
        
        Property String _psCurrentCollateString ""
    End_Procedure

    //>
    Procedure MaxArgumentSizeAdjust Integer iSize Boolean bDownsizeIfPossible
        Integer iCurrentSize iIndex
        Boolean bSet
        Move (SizeOfArray(_gasfMAS)) to iIndex
        Get_Argument_Size to iCurrentSize
        Move (iSize>iCurrentSize or bDownsizeIfPossible) to bSet
        If (bSet) Begin
            Set_Argument_Size iSize
            Move iCurrentSize to _gasfMAS[iIndex].iSize
        End
        Move bSet to _gasfMAS[iIndex].bSet
    End_Procedure
    
    //> See: Class:_cStringFunctions,Procedure:MaxArgumentSizeAdjust
    Procedure MaxArgumentSizeRestore
        Integer iIndex iSize
        Move (SizeOfArray(_gasfMAS)-1) to iIndex
        If (iIndex>=0) Begin
            If (_gasfMAS[iIndex].bSet) Begin
                Move _gasfMAS[iIndex].iSize to iSize
                Set_Argument_Size iSize
            End
            Move (ResizeArray(_gasfMAS,iIndex)) to _gasfMAS
        End
        Else Begin
            Error 666 "Unbalanced argument size push/pop (StringFunctions.pkg)"
        End
    End_Procedure
    
    Function MaxArgumentSize Returns Integer
        Integer iCurrentSize
        Get_Argument_Size to iCurrentSize
        Function_Return iCurrentSize
    End_Function

    Function CurrentCollateString Returns String
        Integer iChar iItem iMax hArr
        String sValue
        If (_psCurrentCollateString(Self)="") Begin
            Get Create (RefClass(Array)) to hArr
            Send Delete_Data of hArr
            For iChar from 32 to 255
                Set Value of hArr (iChar-32) to (Character(iChar))
            Loop
            Send Sort_Items of hArr Ascending // This reveals the true sorting of the current runtime.
            Get Item_Count of hArr to iMax
            Decrement iMax
            Move "" to sValue
            For iItem from 0 to iMax
                Move (sValue+Value(hArr,iItem)) to sValue
            Loop
            Send Destroy of hArr
            Set _psCurrentCollateString to sValue
        End
        Function_Return (_psCurrentCollateString(Self))
    End_Function
    
    //> Flip string
    Function ReverseString String sValue Returns String
        Integer iLen iPos
        String sRval sChar
        Move "" to sRval
        Move (Length(sValue)) to iLen
        For iPos from 1 to iLen 
            Move (Mid(sValue,1,iPos)+sRval) to sRval
        Loop
        Function_Return sRval
    End_Function
    
    //> Negate value so that sorting it as a string will reverse the direction of the original value
    Function NegateString String sValue Returns String
        Integer iPos iLen
        String sRval sChar
        Move (length(sValue)) to iLen
        Move "" to sRval
        For iPos from 1 to iLen
            Move (Mid(sValue,1,iPos)) to sChar
            Move (sRval+Mid(gStr$ReversedCollateString,1,Ascii(sChar))) to sRval
        Loop
        Function_Return sRval
    End_Function
    
        Function _CurrentCollateStringReversed Returns String
            Function_Return (ReverseString(Self,CurrentCollateString(Self)))
        End_Function

    //> Function rPos returns the position of the last occurance of sSubString in sHostString. If
    //> there are no occurances, 0 will be returned. The highest position at which the 'sub string' was found.
    //>
    //> <code>
    //>  get rPos of oStringFunctions "be" "tobeornottobe" to iPos // returns 12 to iPos
    //> </code>
    //>
    Function rPos ;
                  String sSubString ; //> The sequence of characters to be searched for.
                  String sHostString ; //> The string in which to search for the 'sub string'.
                  Returns Integer
        Integer iPos iSubLen
        If (Length(sSubString)=0) Begin
            Function_Return 0
        End
        Move (Length(sHostString)-Length(sSubString)+1) to iPos
        Move (Length(sSubString)) to iSubLen
        While (iPos>0)
            If (Mid(sHostString,iSubLen,iPos)=sSubString) Begin
                Function_Return iPos
            End
            Decrement iPos
        End
        Function_Return 0 // not found
    End_Function

    //> Function rRemove removes iNumChars characters from the right end of sValue.
    Function rRemove String sValue Integer iNumChars Returns String
        Function_Return (Left(sValue,Length(sValue)-iNumChars))
    End_Function

//  //> Function RightFromPos returns the right part of the string starting at position iPos.
//  Function RightFromPos String sValue Integer iPos Returns String
//      Function_Return (remove(sValue,1,iPos-1))
//  End_Function

    Function BeginsWith String sHostString String sLeadInCharacters Returns Boolean
        If (Length(sLeadInCharacters)>Length(sHostString)) Begin
            Function_Return False
        End
        Function_Return (Left(sHostString,Length(sLeadInCharacters))=sLeadInCharacters)
    End_Function

    Function EndsWith String sHostString String sTrailingCharacters Returns Boolean
        If (Length(sTrailingCharacters)>Length(sHostString)) Begin
            Function_Return False
        End
        Function_Return (Right(sHostString,Length(sTrailingCharacters))=sTrailingCharacters)
    End_Function

    Function SearchPos String sSubString String sHostString Integer iStartPos Returns Integer
        Integer iRval
        Move (Pos(sSubString,Remove(sHostString,1,iStartPos-1))) to iRval
        If (iRval) Begin
            Move (iRval+iStartPos-1) to iRval
        End
        Function_Return iRval
    End_Function

    Function psThousandsSeparator Returns String
        If (psDecimalSeparator(Self)=",") Begin
            Function_Return "." // Dot
        End
        Function_Return "," // Comma
    End_Function

    //> The string sValue is returned right justified in a string of length iLen
    Function RightAdjust String sValue Integer iLen Returns String
        Move (Trim(sValue)) to sValue
        Move (Repeat(" ", 0 max (iLen-length(sValue)))+sValue) to sValue
        Function_Return sValue
    End_Function

    //> Inserts thousands separators into the number passed.
    Function InsertThousandsSeparators String sValue Returns String
        Integer iPos
        Boolean bNegative
        String sDecimalSeparator sThousandsSeparator

        Move (Trim(sValue)) to sValue
        Move (Left(sValue,1)="-") to bNegative

        If (bNegative) Begin
            Move (Remove(sValue,1,1)) to sValue // if (lbNegative) get StringRightBut sValue 1 to sValue
        End

        Get psDecimalSeparator to sDecimalSeparator
        Move (Pos(sDecimalSeparator,sValue)) to iPos
        If (iPos=0) Begin
            Move (Length(sValue)+1) to iPos
        End
 
        Get psThousandsSeparator to sThousandsSeparator

        While (iPos>4)
            Move (iPos-3) to iPos
            Move (Insert(sThousandsSeparator,sValue,iPos)) to sValue
        Loop
        If (bNegative) Begin
            Move ("-"+sValue) to sValue
        End
        Function_Return sValue
    End_Function

    //> Removes thousands separators from the string passed and dares comvert it into a number.
    Function RemoveThousandsSeparators String sValue Returns Number
        Move (Replaces(psThousandsSeparator(Self),sValue,"")) to sValue
        Function_Return (Number(sValue))
    End_Function

    //> Calling the function below will convert the number passed in nNumber to a
    //> string containing iDecimals decimals rounding excess decimals. Parameter iDecimals
    //> may be negative. The expression (NumberToString(oStringFunctions,1789,-3)) will evaluate to "2000".
    //> The function handles a maximum of 8 decimals.
    Function NumberToString Number nValue Integer iDecimals Returns String
        Integer iPos iAscii
        Number nCorr
        String sRval sDecimalSeparator
        If (iDecimals<0) Begin
            Function_Return (NumberToString(Self,nValue*(10^iDecimals),0)+left("00000000",-iDecimals))
        End
        Move (0.5/(10^iDecimals)) to nCorr
        If (nValue>=0) Begin
            Move (nCorr+nValue) to nValue
        End
        Else Begin
            Move (nValue-nCorr) to nValue
        End
        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
        Move (Character(iAscii)) to sDecimalSeparator
        Move nValue to sRval
        If (not(Pos(sDecimalSeparator,sRval))) Begin
            Move (sRval+sDecimalSeparator) to sRval
        End
        Move (sRval+"00000000") to sRval
        Move (Pos(sDecimalSeparator,sRval)) to iPos
        If (iDecimals=0) Begin
            Decrement iPos
        End
        Move (Left(sRval,iPos+iDecimals)) to sRval
        If (_pbInsertThousandsSeparators(Self)) Begin
            Get InsertThousandsSeparators sRval to sRval
        End
        Function_Return sRval
    End_Function

    //> This function is the same as NumberToString except that you have to specify
    //> the length of the return value (iLen). The number will be right
    //> justified accordingly. Post-fix `R' means right adjust.
    Function NumberToStringR Number nValue Integer iDecimals Integer iLen Returns String
        Function_Return (RightAdjust(Self,NumberToString(Self,nValue,iDecimals),iLen))
    End_Function

    //> Function NumberToStringTS is the same as NumberToString except that thousands
    //> separators are inserted. (TS=Thousands Separator)
    Function NumberToStringTS Number nValue Integer iDecimals Returns String
        String sRval
        Set _pbInsertThousandsSeparators to True
        Get NumberToString nValue iDecimals to sRval
        Set _pbInsertThousandsSeparators to False
        Function_Return sRval
    End_Function

    //> This function is identical to NumberToStringTS except that you have to specify
    //> the length of the return value (iLen). The return value will be right
    //> justified accordingly.
    Function NumberToStringRTS Number nValue Integer iDecimals Integer iLen Returns String
        String sRval
        Get NumberToStringTS nValue iDecimals to sRval
        Get RightAdjust sRval iLen to sRval
        Function_Return sRval
    End_Function

    //> The number nValue is rounded to 0 decimals and returned right justified in a string of
    //> length iLen. Lead in blanks are substituted for zeros (zf=zero fill).
    Function IntegerToStringRzf Number nValue Integer iLen Returns String
        String sRval
        Get NumberToStringR nValue 0 iLen to sRval
        Function_Return (replaces(" ",sRval,"0"))
    End_Function
    
    Function StringToNumber String sValue Returns Number
        String sDec sNotDec
        Number nValue
        Get psDecimalSeparator to sDec
        Get psThousandsSeparator to sNotDec
        Move (Replace(sNotDec,sValue,sDec)) to sValue
        Move sValue to nValue
        Function_Return nValue
    End_Function

    //> Use this function to obtain the number of the least significant "non zero
    //> decimal in nValue. 0.702 will return 3 while 100 will return -2.
    Function NumberOfDecimals Number nValue Returns Integer
        Integer iCount
        String sNumber sDecimalSeparator

        If (nValue=0) Begin
            Function_Return 0 // Special case
        End
        Move nValue to sNumber // This removes superfluous decimals

        Get psDecimalSeparator to sDecimalSeparator
        If (pos(sDecimalSeparator,sNumber)) Begin
            Function_Return (length(sNumber)-pos(sDecimalSeparator,sNumber))
        End

        Move 0 to iCount
        While (right(sNumber,1)="0")
            Move (left(sNumber,length(sNumber)-1)) to sNumber
            Decrement iCount
        End
        Function_Return iCount
    End_Function

    //> IsInteger returns True if the value held by the sValue parameter is an integer (the function does not handle thousand seps).
    //> Note that even if this function returns True it may still not be possible to 'Move' the value to an integer variable. This will
    //> be the case if the value falls outside of the integer value range (-2147483648 to 2147483647)
    Function IsInteger String sValue Returns Boolean
        Integer iPos iLen
        Move (Trim(sValue)) to sValue
        If (Left(sValue,1)="-") Begin
            Move (Replace("-",sValue,"")) to sValue
        End
        Move (Length(sValue)) to iLen
        For iPos from 1 to iLen
            If (not(Pos(Mid(sValue,1,iPos),"0123456789"))) begin
                Function_Return False
            End
        Loop
        Function_Return True
    End_Function

    //> This function returns True if sValue is a number or an integer (the function does not handle thousand seps)
    //> Note that even if this function returns True it may still not be possible to 'Move' the value to a number variable. This will
    //> be the case if the value falls outside of the number value range (+/-99999999999999.99999999)
    Function IsNumber String sValue String sDecimalSeparator Returns Boolean
        Integer iLen iPos iAscii
        Boolean bDecSepFound
        String sChar sSep
        Move False to bDecSepFound
        Move (Trim(sValue)) to sValue
        If (Left(sValue,1)="-") Begin
            Move (Replace("-",sValue,"")) to sValue
        End
        If (num_arguments>1) Begin
            Move sDecimalSeparator to sSep
            If (not(",." contains sSep)) Begin // This error check may be removed in january 1st 2013
                Error 666 "Decimal separator must be ',' or '.'"
            End
        End
        Else Begin
            Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
            Move (Character(iAscii)) to sSep
        End
        Move (Length(sValue)) to iLen
        For iPos from 1 to iLen
            Move (Mid(sValue,1,iPos)) to sChar
            If (sChar=sSep) Begin
                If bDecSepFound Begin
                    Function_Return False
                End
                Move True to bDecSepFound
            End
            Else If (not("0123456789" contains sChar)) Begin 
                Function_Return False
            End
        Loop
        Function_Return True
    End_Function
    
    //> Returns the number of positions in sValue occupied by a characters in sCountCharacters
    Function CharacterCount String sValue String sCountCharacters Returns Integer
        Integer iPos iLength iCount
        Move 0 to iCount
        Move (Length(sValue)) to iLength
        For iPos from 1 to iLength
            If (sCountCharacters contains Mid(sValue,1,iPos)) Begin
                Increment iCount
            End
        Loop
        Function_Return iCount
    End_Function
    
    //> Convert a byte value (0-255) to its hex equivalent. Passing for example 27 makes it return "1B".
    Function ByteToHex Integer iByte Returns String
        Function_Return (Mid("0123456789ABCDEF",1,iByte/16+1)+Mid("0123456789ABCDEF",1,(iByte iand 15)+1))
    End_Function

    //> Convert a hexadecimal value to its byte equivalent: Passing "FF" for example makes it return 255.
    Function HexToByte String sHex Returns Integer
        Move (Uppercase(sHex)) to sHex
        Function_Return (Pos(Left(sHex,1),"0123456789ABCDEF")-1*16+Pos(Right(sHex,1),"0123456789ABCDEF")-1)
    End_Function
    
    Function IsHex String sHex Returns Boolean
        Integer iLen iPos
        String sChar
        Move (Length(sHex)) to iLen
        If (((iLen/2)*2)<>iLen) Begin
            Function_Return False // Must be an equal number of characters
        End
        Move (Uppercase(sHex)) to sHex
        For iPos from 1 to iLen
            Move (Mid(sHex,1,iPos)) to sChar
            If (not("0123456789ABCDEF" contains sChar)) Begin
                Function_Return False
            End
        Loop
        Function_Return True
    End_Function

    //> Convert a string of characters to a string of hexadecimal values.
    Function StringToHex String sValue Returns String
        Integer iLen iPos
        String sRval
        Move (Length(sValue)) to iLen
        Move "" to sRval
        For iPos from 1 to iLen
            Move (String(sRval)+String(ByteToHex(Self,Ascii(Mid(sValue,1,iPos))))) to sRval
        Loop
        Function_Return sRval
    End_Function

    //> Convert a string of hexadecimal values to a string of characters.
    Function HexToString String sValue Returns String
        Integer iLen iPos
        String sRval
        Move (Length(sValue)/2) to iLen
        Move "" to sRval
        For iPos from 1 to iLen
            Move (String(sRval)+Character(HexToByte(Self,Mid(sValue,2,iPos*2-1)))) to sRval
        Loop
        Function_Return sRval
    End_Function

                    Function _iEncryptXor.iii Integer iXval Integer iYval Integer iBitCount Returns Integer // Private
                        Integer iRval iBit iXbit iYbit iBitExp
                        Move 0 to iRval
                        For iBit from 0 to (iBitCount-1)
                            Move (2^iBit) to iBitExp
                            Move ((iXval/iBitExp)-(((iXval/iBitExp)/2)*2)) to iXbit
                            Move ((iYval/iBitExp)-(((iYval/iBitExp)/2)*2)) to iYbit
                            If (iXbit<>iYbit) Begin
                                Move (iRval+iBitExp) to iRval
                            End
                        Loop
                        Function_Return iRval
                    End_Function

    // The same function (Encrypt) is used to encrypt and decrypt a string:
    //
    //          Encrypt(string,code)
    //                  |  Encrypt(encrypted_string,key)
    //                  |                      |
    //                  v                      v
    //        <string> --> <encrypted string> --> <string>
    //
    // The code used to encrypt a string may be any integer value and must
    // be the same when decrypting.
    //
    // Note that this is a very very weak encryption that can be decoded
    // easily. It only obscures the content from poeple that do not want
    // to know.

    // silly and simple way of encrypting a string. should not be used.
    Function Encrypt String sInput Integer iKey Integer iLen Returns String
        Integer iPos
        String sRval
        Move "" to sRval
        For iPos from 1 to iLen
            Move (sRval+character(_iEncryptXor.iii(Self,ascii(mid(pad(sInput,iLen),1,iPos)),((iKey+(iPos*7)) iand 31),8))) to sRval
        Loop
        Function_Return sRval
    End_Function

    //> The SplitString procedure splits the value in sValue into a number of items based on the character in the sSeparatorChar
    //> parameter. These items are returned (by reference) in the aValues parameter.
    //>
    Procedure SplitString ;
                          String sValue ;                    //> The string to be divided into items.
                          String sSeparatorChar ;            //> Determines which character(s) is considered a "dividing" character.
                          Boolean bIgnoreDoubleSeparators ;  //> If two or more separater characters are encountered in immediate succession, this parameter decides whether they should be considered as one divider or as a number of separate dividers.
                          Boolean bProtectQuotes ;           //> If this is true, strings in quotes (single or double) will not be scanned for separating characters.
                          String[] ByRef aValues             //> The result. The array is reset during procedure initialization.
        Integer iLen       // Length of the string we are parsing
        Integer iItem      // Pointer to the next available index in the target array (aValues)
        Integer iStartItem // Number of items originally in the target array
        Integer iPos       // The current position in the string (sValue) we are parsing

        String  sChar      // The character currently being examined by the loop
        String  sItem      // The value of the next item as it is being built
        String  sQuoteChar // If " or ', we are currently in a quoted section of the string
        String  sQuotes    // Quotation characters: "'

        Move "" to sQuoteChar

        Move (ResizeArray(aValues,0)) to aValues
        Move 0 to iStartItem

        Move iStartItem to iItem
        Move (length(sValue)) to iLen
        
        If (iLen=0) Begin // If zero length we return the empty array
            Procedure_Return
        End
        
        Move "" to sItem
        Move ("'"+'"') to sQuotes

        Move 1 to iPos
        If (bIgnoreDoubleSeparators) Begin // Leadin separating characters are to be disregarded, we advance the position accordingly
            While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
              Increment iPos
            End
        End
        While (iPos<=iLen)
            Move (mid(sValue,1,iPos)) to sChar
            Increment iPos
                                                                          
            If (sQuoteChar<>"") Begin
                If (sChar=sQuoteChar) Begin
                    Move "" to sQuoteChar
                End
                Move (sItem+sChar) to sItem
            End
            Else Begin // We're not in a quote
                If (sSeparatorChar contains sChar) Begin
                    Move sItem to aValues[iItem]
                    Increment iItem
                    Move "" to sItem

                    If (bIgnoreDoubleSeparators) Begin // succeeding separating characters are to be considered as one, we advance the position accordingly
                        While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
                          Increment iPos
                        End
                    End
                End
                Else If (bProtectQuotes<>0 and sQuotes contains sChar) Begin
//                Else If (bProtectQuotes<>0 and sQuotes contains sChar and Trim(sItem)="") Begin
                    Move sChar to sQuoteChar
                    Move (sItem+sChar) to sItem
                End
                Else Begin
                    Move (sItem+sChar) to sItem
                End
            End
        End

        // Added "or not(bIgnoreDoubleSeparators)" to the below statement to add the last item, even if it's blank
        If (sItem<>"" or not(bIgnoreDoubleSeparators)) Begin
            Move sItem to aValues[iItem]
            Increment iItem
        End
    End_Procedure // SplitString

            Function _SplitStringReverse String[] aValues String sSeparator Integer iMinIndex Integer iMaxIndex Returns String
                Integer iIndex
                String sRval
                String sValue

                Move (iMaxIndex min (SizeOfArray(aValues)-1)) to iMaxIndex
                Move (iMinIndex max 0) to iMinIndex

                Move "" to sRval
                For iIndex from iMinIndex to iMaxIndex
                    Move aValues[iIndex] to sValue
                    Move (sRval+sValue) to sRval
                    If (iIndex<>iMaxIndex) Begin
                        Move (sRval+sSeparator) to sRval
                    End
                Loop
                Function_Return sRval
            End_Function

    //> Concatenate the items of the array, separated by sSeparator's, into a string.
    //> Pass non zero values for iSkipHead and iSkipTail to omit items at either "end" of the array.
    Function JoinString String[] aValues String sSeparator Integer iSkipHead Integer iSkipTail Returns String
        Integer iMax
        Move (SizeOfArray(aValues)-1) to iMax
        Function_Return (_SplitStringReverse(Self,aValues,sSeparator,iSkipHead,iMax-iSkipTail))
    End_Function

//    Function SplitStringHead String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes Returns String
//        String[] aValues
//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
//        If (SizeOfArray(aValues)) Function_Return aValues[0]
//        Function_Return ""
//    End_Function
//
//    Procedure SplitStringTail String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes String[] ByRef aValues
//        Integer iSize
//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
//        Move (SizeOfArray(aValues)) to iSize
//        If (iSize>1) Move (CopyArray(aValues,1,iSize-1)) to aValues
//        Else Move (ResizeArray(aValues,0)) to aValues
//    End_Procedure

            Procedure _WildCardAddItem tWildCardEvalSequence ByRef sSequence Integer iType String sValue // Private
                Integer iSize
                Move (SizeOfArray(sSequence.aSequence)) to iSize
                Move iType to sSequence.aSequence[iSize].iType
                Move sValue to sSequence.aSequence[iSize].sValue
            End_Procedure

            Procedure _WildCardOptimizeSequence tWildCardEvalSequence ByRef sSequence // Private
                Integer iSize

                Move (SizeOfArray(sSequence.aSequence)) to iSize
                Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
                Move False to sSequence.bAltStrategyRejectOnly
                If (iSize=1) Begin
                    If (sSequence.aSequence[0].iType=_WILDC_ASTERISK) Begin
                        Move _WILDC_ALWAYS_TRUE to sSequence.iAltStrategy
                    End
                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin
                        Move _WILDC_EQUAL to sSequence.iAltStrategy
                        Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
                    End
                End
                Else if (iSize>0) Begin
                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin // If leftmost is a constant
                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // if rightmost is also a constant
                            If (iSize=3 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
                            End
                            Else Begin
                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
                                Move True to sSequence.bAltStrategyRejectOnly
                            End
                        End
                        Else Begin
                            If (iSize=2 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
                            End
                            Else Begin
                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
                                Move True to sSequence.bAltStrategyRejectOnly
                            End
                        End
                    End
                    Else Begin
                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // If rightmost is a constant
                            If (iSize=2 and sSequence.aSequence[0].iType=_WILDC_ASTERISK) Begin
                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
                            End
                            Else Begin
                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
                                Move True to sSequence.bAltStrategyRejectOnly
                            End
                        End
                        Else Begin // Now we check if first and last are asterisks
                            If (iSize=3 and sSequence.aSequence[0].iType=_WILDC_ASTERISK and sSequence.aSequence[1].iType=_WILDC_CONSTANT and sSequence.aSequence[2].iType=_WILDC_ASTERISK) Begin
                                Move _WILDC_CONTAINS to sSequence.iAltStrategy
                                Move sSequence.aSequence[1].sValue to sSequence.sAltStrategyLeftValue
                            End
                        End
                    End
                End
            End_Procedure

    //> Return a black-box value to be used for evaluating string values against a file-name style mask. Can be _very_ expensive.
    //>
    //> Example:
    //> <code>
    //>  Get WildCardEvalSequence of oStringFunction "*.pkg" to stMyWildCardEvalSequence
    //>  If (WildCardMatch(oStringFunctions,"StringFunctions.pkg",stMyWildCardEvalSequence)) Begin
    //>      Showln "A match!"
    //>  End
    //> </code>
    Function WildCardEvalSequence String sMask Returns tWildCardEvalSequence
        Integer iLen iPos
        String sItem sChar
        tWildCardEvalSequence sSequence
        Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
        Move (Replaces("**",sMask,"*")) to sMask // Simple reduction
        Move (Length(sMask)) to iLen
        Move "" to sItem
        For iPos from 1 to iLen
            Move (Mid(sMask,1,iPos)) to sChar
            If (sChar="*") Begin
                If (sItem<>"") Begin
                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
                    Move "" to sItem
                End
                Send _WildCardAddItem (&sSequence) _WILDC_ASTERISK ""
            End
            Else If (sChar="?") Begin
                If (sItem<>"") Begin
                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
                    Move "" to sItem
                End
                Send _WildCardAddItem (&sSequence) _WILDC_QUESTIONMARK ""
            End
            Else Begin
                Move (sItem+sChar) to sItem
            End
        Loop
        If (sItem<>"") Begin
            Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
        End
        Send _WildCardOptimizeSequence (&sSequence)
        Function_Return sSequence
    End_Function

    Function WildCardEvalSequences String[] aMasks Returns tWildCardEvalSequence[]
        Integer iItem iMax
        tWildCardEvalSequence[] aSeq
        Move (SizeOfArray(aMasks)-1) to iMax
        For iItem from 0 to iMax
            Get WildCardEvalSequence aMasks[iItem] to aSeq[iItem]
        Loop
        Function_Return aSeq
    End_Function

    Procedure AddWildCardEvalSequence String sMask tWildCardEvalSequence[] ByRef aEvalSequences
        Integer iIndex
        Move (SizeOfArray(aEvalSequences)) to iIndex
        Get WildCardEvalSequence sMask to aEvalSequences[iIndex]
    End_Procedure

    Procedure AddWildCardEvalSequences String[] aMasks tWildCardEvalSequence[] ByRef aEvalSequences
        Integer iIndex iMax
        Move (SizeOfArray(aMasks)-1) to iMax
        For iIndex from 0 to iMax
            Send AddWildCardEvalSequence aMasks[iIndex] (&aEvalSequences)
        Loop
    End_Procedure

            Function _WildCardMatchRecursive Integer iItem String sValue tWildCardEvalSequence ByRef sSequence Returns Boolean // Private
                Integer iMax iType iLen iPos
                String sItem
                Move (SizeOfArray(sSequence.aSequence)) to iMax
                If (iItem>=iMax) Begin
                    Function_Return (sValue="")
                End
                Move sSequence.aSequence[iItem].iType to iType
                If (iType=_WILDC_CONSTANT) Begin // constant
                    If (length(sValue)=0) Begin
                        Function_Return False
                    End
                    Move sSequence.aSequence[iItem].sValue to sItem
                    Move (length(sItem)) to iLen
                  //If (sItem=left(sValue,iLen)) Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iLen+1),&sSequence))
                    If (sItem=left(sValue,iLen)) Begin
                        Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iLen),&sSequence))
                    End
                    Function_Return 0
                End
                If (iType=_WILDC_QUESTIONMARK) Begin // ?
                    If (length(sValue)=0) Begin
                        Function_Return False
                    End
                  //Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,2),&sSequence))
                    Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,1),&sSequence))
                End
                If (iType=_WILDC_ASTERISK) Begin // *
                    If (iItem=(iMax-1)) Begin
                        Function_Return True
                    End
                    Move (length(sValue)) to iLen
                    For iPos from 0 to iLen
                      //If (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iPos+1),&sSequence)) Function_Return True
                        If (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iPos),&sSequence)) Begin
                            Function_Return True
                        End
                    Loop
                End
                Function_Return False
            End_Function

    Function WildCardMatch String sValue tWildCardEvalSequence sSequence Returns Boolean
        Integer iPos iPosEnd
        String sWordCharacters
        If (sSequence.iAltStrategy=_WILDC_ALWAYS_TRUE) Begin
            Function_Return True
        End
        If (sSequence.iAltStrategy=_WILDC_EQUAL) Begin
            Function_Return (sValue=sSequence.sAltStrategyLeftValue)
        End
        If (sSequence.iAltStrategy=_WILDC_LEFT_MATCH) Begin
            If (sSequence.bAltStrategyRejectOnly) Begin
                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))) Begin
                    Function_Return False
                End
            End
            Else Begin
                Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))
            End
        End
        If (sSequence.iAltStrategy=_WILDC_RIGHT_MATCH) Begin
            If (sSequence.bAltStrategyRejectOnly) Begin
                If (not(EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
                    Function_Return False
                End
            End
            Else Begin
                Function_Return (EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
            End
        End
        If (sSequence.iAltStrategy=_WILDC_LEFT_AND_RIGHT_MATCH) Begin
            If (sSequence.bAltStrategyRejectOnly) Begin
                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
                    Function_Return False
                End
            End
            Else Begin
                Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
            End
        End
        If (sSequence.iAltStrategy=_WILDC_CONTAINS) Begin
            Function_Return (sValue contains sSequence.sAltStrategyLeftValue)
        End
        If (sSequence.iAltStrategy=_WILDC_CONTAINS_WORDONLY) Begin
            Move 1 to iPos
            Get psWildCardWordCharacters to sWordCharacters
            While (iPos>0)
                Move (Pos(sSequence.sAltStrategyLeftValue,sValue,iPos)) to iPos
                If (iPos>0) Begin
                    If (iPos=1 or not(sWordCharacters contains Mid(sValue,1,iPos-1))) Begin
                        Move (iPos+Length(sSequence.sAltStrategyLeftValue)) to iPosEnd
                        If (iPosEnd>Length(sValue) or not(sWordCharacters contains Mid(sValue,1,iPosEnd))) Begin
                            Function_Return True
                        End
                    End
                    Increment iPos
                End
            Loop
            Function_Return False
        End
        Function_Return (_WildCardMatchRecursive(Self,0,sValue,&sSequence))
    End_Function

    Function WildCardMatchAny String sValue tWildCardEvalSequence[] aSequences Returns Boolean
        Integer iItm iMax
        Move (SizeOfArray(aSequences)) to iMax
        Decrement iMax
        For iItm from 0 to iMax
            If (WildCardMatch(Self,sValue,aSequences[iItm])) Begin
                Function_Return True
            End
        Loop
        Function_Return False
    End_Function

    Function WildCardMatchAll String sValue tWildCardEvalSequence[] aSequences Returns Boolean
        Integer iItm iMax
        Move (SizeOfArray(aSequences)) to iMax
        Decrement iMax
        For iItm from 0 to iMax
            If (not(WildCardMatch(Self,sValue,aSequences[iItm]))) Begin
                Function_Return False
            End
        Loop
        Function_Return True
    End_Function

    Function UppercaseFirstLetters String sValue Returns String
        Boolean bInWord
        Integer iLen iPos
        String sRval sChar
        Move (Lowercase(sValue)) to sValue
        Move (Length(sValue)) to iLen
        Move 0 to bInWord
        For iPos from 1 to iLen
            Move (Mid(sValue,1,iPos)) to sChar
            If (sChar="") Begin
                Move False to bInWord
            End
            Else Begin
                If (not(bInWord)) Begin
                    Move (Uppercase(sChar)) to sChar
                    Move True to bInWord
                End
            End
            Move (sRval+sChar) to sRval
        Loop
        Function_Return sRval
    End_Function

    // Knut Sparhell pointed to this address for a thorough explanation: http://www.merriampark.com/ld.htm
    Function LongestCommonSequence String sWord1 String sWord2 Returns Integer
        Integer iLen1 iLen2
        Integer iPos1 iPos2
        Integer[][] aArray
        Move (length(sWord1)) to iLen1
        Move (length(sWord2)) to iLen2
        If (iLen1=0 or iLen2=0) Begin
            Function_Return 0
        End
        For iPos1 from 1 to iLen1
            Move 0 to aArray[iPos1][0]
            For iPos2 from 1 to iLen2
                If (iPos1=1) Begin
                    Move 0 to aArray[0][iPos2]
                End
                If (mid(sWord1,1,iPos1)=mid(sWord2,1,iPos2)) Begin
                    Move (aArray[iPos1-1][iPos2-1]+1) to aArray[iPos1][iPos2]
                End
                Else If (aArray[iPos1-1][iPos2]>=aArray[iPos1][iPos2-1]) Begin
                    Move aArray[iPos1-1][iPos2] to aArray[iPos1][iPos2]
                End
                Else Begin
                    Move aArray[iPos1][iPos2-1] to aArray[iPos1][iPos2]
                End
            Loop
        Loop
        Function_Return aArray[iLen1][iLen2]
    End_Function

    //> Returns the number of faulty keystrokes needed for sWord1 to accidentally become sWord2 (called the "Levenshtein distance")
    Function SpellingDistance String sWord1 String sWord2 Returns Integer
        Integer iLCS iMaxLen
        Move (length(sWord1) max length(sWord2)) to iMaxLen
        Get LongestCommonSequence sWord1 sWord2 to iLCS
        Function_Return (iMaxLen-iLCS)
        Function_Return (Length(sWord1)+Length(sWord2)-iLCS-iLCS)
    End_Function

    Define GPW_VOCALS     for "aeiouy"
    Define GPW_CONSONANTS for "bcdfghjklmnpqrstvwxz"

    //> This function generates a password composed from a number of random syllables (consonant+vocal). The iLen
    //> parameter specifues the number of syllables (and therefore half the length of the return value measured in characters)
    Function GenerateRandomPassword Integer iLen Returns String
        Integer iPos iPosV iPosC iLenV iLenC
        String sRval
        Move (Length(GPW_CONSONANTS)) to iLenC
        Move (Length(GPW_VOCALS)) to iLenV
        For iPos from 1 to iLen
            Move (Random(iLenC)) to iPosC
            Move (Random(iLenV)) to iPosV
            Move (sRval+Mid(GPW_CONSONANTS,1,iPosC+1)+Mid(GPW_VOCALS,1,iPosV+1)) to sRval
        Loop
        Function_Return sRval
    End_Function

    Function QuickHtmlEncode String sValue Returns String
        Integer iLen iPos
        String sRval sChar
        Move (Length(sValue)) to iLen
        For iPos from 1 to iLen
            Move (Mid(sValue,1,iPos)) to sChar
            If (sChar='"') Begin
                Move (sRval+"&quot;") to sRval
            End
            Else If (sChar="&") Begin
                Move (sRval+"&amp;") to sRval
            End
            Else If (sChar="<") Begin
                Move (sRval+"&lt;") to sRval
            End
            Else If (sChar=">") Begin
                Move (sRval+"&gt;") to sRval
            End
            Else Begin
                Move (sRval+sChar) to sRval
            End
        Loop
        Function_Return sRval
    End_Function
    
    Function MakeColumnNameNice String sLabel Returns String
        Boolean bPrevCharWasUC
        Integer iPos iLen
        String sRval sChar
        If (sLabel=Uppercase(sLabel)) Begin // If all uppercase then lowercase
            Move (Lowercase(sLabel)) to sLabel
        End
        Move (Trim(Replaces("_",sLabel," "))) to sLabel
        Move (Length(sLabel)) to iLen
        Move (Left(sLabel,1)) to sRval
        Move (sRval<>Lowercase(sRval)) to bPrevCharWasUC
        For iPos from 2 to iLen
            Move (Mid(sLabel,1,iPos)) to sChar
            If (sChar=Uppercase(sChar) and sChar<>"" and not(bPrevCharWasUC)) Begin
                Move (sRval+" ") to sRval
                Move True to bPrevCharWasUC
            End
            If (sChar=Lowercase(sChar)) Begin
                Move False to bPrevCharWasUC
            End
            Move (sRval+sChar) to sRval
        Loop
        Move (Replaces("  ",sRval," ")) to sRval
        Function_Return (UppercaseFirstLetters(Self,sRval))
    End_Function
    
    Procedure StripQuotes String ByRef sValue
        Integer iLen
        String sFirst sLast
        Move (Length(sValue)) to iLen
        If (iLen>1) Begin
            Move (Left(sValue,1)) to sFirst
            Move (Right(sValue,1)) to sLast
            If (("'"+'"') contains sFirst and sFirst=sLast) Begin
                Move (Mid(sValue,iLen-2,2)) to sValue
            End
        End
    End_Procedure
    
    Function AddQuotes String ByRef sValue String sQuoteToCharacterPreferred Returns Boolean
        If (sQuoteToCharacterPreferred="") Begin
            Move '"' to sQuoteToCharacterPreferred
        End                           
        
        If (Pos(sQuoteToCharacterPreferred,sValue)>0) Begin
            Move (If(sQuoteToCharacterPreferred="'",'"',"'")) to sQuoteToCharacterPreferred
        End
        If (Pos(sQuoteToCharacterPreferred,sValue)=0) Begin
            Move (sQuoteToCharacterPreferred+sValue+sQuoteToCharacterPreferred) to sValue
            Function_Return True
        End
        Function_Return False
    End_Function
            
    Function ItemsInString String sSymbolCharacters String sValue Returns Integer[]
        Integer iPos iLength
        Integer[] aValues
        Boolean bInValue
        String sChar sNextInteger
        Move False to bInValue
        Move (Length(sValue)) to iLength
        For iPos from 1 to iLength
            Move (Mid(sValue,1,iPos)) to sChar
            If (sSymbolCharacters contains sChar) Begin
                If (bInValue) Begin
                    Move (sNextInteger+sChar) to sNextInteger    
                End
                Else Begin
                    Move sChar to sNextInteger
                    Move True to bInValue
                End
            End
            Else Begin
                If (bInValue) Begin
                    Move (Integer(sNextInteger)) to aValues[SizeOfArray(aValues)]
                    Move False to bInValue
                End 
                Else Begin
                    // do nothing
                End
            End
        Loop
    
        If (bInValue) Begin
            Move (Integer(sNextInteger)) to aValues[SizeOfArray(aValues)]
        End
        Function_Return aValues
    End_Function
    
    // Get FormatTimeInput of oStringFunctions "1123" 23
    Function FormatTimeInput String sInput Integer iMaxHour Boolean ByRef bError Returns String
        Integer iVal iHour iMinute
        String sReturn
        Integer[] aIntegers
        
        Move False to bError
        
        Get ItemsInString "0123456789" sInput to aIntegers
        Move "" to sReturn
        If (SizeOfArray(aIntegers)>0) Begin
            If (SizeOfArray(aIntegers)=1) Begin
                Move aIntegers[0] to iVal
                If (iVal<=iMaxHour) Begin
                    Move (IntegerToStringRzf(Self,iVal,2)+":00") to sReturn
                End
                Else If (iVal<60) Begin
                    Move ("00:"+IntegerToStringRzf(Self,iVal,2)) to sReturn
                End
                Else If (iVal>99) Begin
                    If (iVal<((iMaxHour+1)*100)) Begin
                        Move (iVal/100) to iHour
                        Move (Mod(iVal,100)) to iMinute
                        If (iMinute<60) Begin
                            Move (IntegerToStringRzf(Self,iHour,2)+":"+IntegerToStringRzf(Self,iMinute,2)) to sReturn
                        End
                        Else Begin
                            Move True to bError // Minutes > 59
                        End
                    End
                    Else Begin
                        Move True to bError // Not decodabel
                    End
                End
            End
            Else If (SizeOfArray(aIntegers)=2) Begin
                If (aIntegers[0]<(iMaxHour+1) and aIntegers[1]<60) Begin
                    Move (IntegerToStringRzf(Self,aIntegers[0],2)+":"+IntegerToStringRzf(Self,aIntegers[1],2)) to sReturn
                End
                Else Begin
                    Move True to bError
                End
            End
            Else Begin
                Move True to bError
            End
        End
        Else Begin
            Move "" to sReturn
            Move False to bError
        End
        Function_Return sReturn
    End_Function
    
    Function PadNBSP String sValue Integer iPadding Returns String
        String sNBSP
        Move (Character(255)) to sNBSP
        Move (Repeat(sNBSP,iPadding)+sValue+Repeat(sNBSP,iPadding)) to sValue
        Function_Return sValue
    End_Function
            
#IFNDEF Is$WebApp // If Windows application
    Procedure Info_Box_String_Debug String sValue
        Integer iPos iLength
        String sShow
        String[] aValues
        Move (Length(sValue)) to iLength
        For iPos from 1 to iLength
            Move (String(Ascii(Mid(sValue,1,iPos)))) to aValues[iPos-1]
        Loop
        Get JoinString aValues "," 0 0 to sShow
        Send Info_Box sShow
    End_Procedure
#ENDIF

        Function _ONTHCharCount String sChar String sValue Returns Integer
            Integer iOldLength iNewLength
            Move (Length(sValue)) to iOldLength
            Move (Replaces(sChar,sValue,"")) to sValue
            Move (Length(sValue)) to iNewLength
            Function_Return (iOldLength-iNewLength)
        End_Function
    
    //> "oWebApp.OrderEntry.oCustomer_Name" -> object handle
    Function ObjectNameToHandle String sObject Returns Integer
        String[] aValues
        String sEval
        Integer hObject
        Move 0 to hObject
        Send SplitString sObject "." False False (&aValues)
        If (SizeOfArray(aValues)>0) Begin
            Move (ReverseArray(aValues)) to aValues
            Move "desktop" to aValues[SizeOfArray(aValues)]
            Get JoinString aValues "(" 0 0 to sEval
            Move ("("+sEval) to sEval
            Move (sEval+Repeat(")",_ONTHCharCount(Self,"(",sEval))) to sEval
            Move (Eval(sEval)) to hObject
        End
        Function_Return hObject
    End_Function


End_Class

Global_Variable Integer oStringFunctions

Object _oStringFunctions is a _cStringFunctions 
    Move Self to oStringFunctions
    // This only needs to be done once in the lifetime of the app. 
    Get _CurrentCollateStringReversed to gStr$ReversedCollateString
    Move (Repeat(" ",31)+gStr$ReversedCollateString) to gStr$ReversedCollateString
End_Object
